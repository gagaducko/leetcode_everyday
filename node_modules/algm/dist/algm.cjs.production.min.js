"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,e=null,r=null){this.val=t,this.left=e,this.right=r}}function e(t){if(!t)return JSON.stringify([]);let e=[],r=[t];for(;r.length;){let t=r.shift();t?(e.push(t.val),r.push(t.left),r.push(t.right)):e.push(null)}let n=e.length-1;for(;null===e[n];)n--;return e.length=n+1,JSON.stringify(e)}function r(e){const r=JSON.parse(e);if(!r.length)return null;let n=r.shift(),s=new t(n),i=[s];for(;i.length;){let e=i.shift(),n=r.shift();if(void 0===n)return s;if(null!==n){let r=new t(n);e.left=r,i.push(r)}let l=r.shift();if(void 0===l)return s;if(null!==l){let r=new t(l);e.right=r,i.push(r)}}return s}var n={__proto__:null,TreeNode:t,serialize:e,deserialize:r,serializeArr:function(t){const r=[];for(let n=0;n<t.length;n++)r.push(e(t[n]));return"["+r.join(",")+"]"},deserializeArr:function(t){const e=JSON.parse(t);if(!e.length)return[];let n=[];for(let t=0;t<e.length;t++)n.push(r(JSON.stringify(e[t])));return n}};class s{constructor(t,e=null){this.val=t,this.next=e}}function i(t){if(!t)return JSON.stringify([]);let e=[],r=t;for(;r;)e.push(r.val),r=r.next;return JSON.stringify(e)}function l(t){const e=JSON.parse(t);let r=new s,n=r;for(let t=0;t<e.length;t++)n.next=new s(e[t]),n=n.next;return r.next}var o={__proto__:null,ListNode:s,serialize:i,serializeArr:function(t){let e=[];for(let r=0;r<t.length;r++)e.push(i(t[r]));return"["+e.join(",")+"]"},deserialize:l,deserializeArr:function(t){const e=JSON.parse(t);let r=[];for(let t=0;t<e.length;t++)r.push(l(JSON.stringify(e[t])));return r},reverseList:function(t){if(!t)return null;let e=null,r=t;for(;r;){let t=r.next;r.next=e,e=r,r=t}return e}};function h(t,e){if(typeof t!=typeof e)throw new Error("the type of key should be the same");return"string"!=typeof t?t-e:t.localeCompare(e)}function u(t,e=(t=>t),r=e){return t.sort((t,n)=>h(e(t),e(n))||h(r(t),r(n)))}function a(t,e=(t=>t),r=e){return t.sort((t,n)=>{const s=e(t),i=h(e(n),s);if(i)return i;const l=r(t);return h(r(n),l)})}function f(t){return t[t.length-1]}function c(...t){if(!Array.isArray(t[0]))return Math.max(...t);if((t=t[0]).length<=1e4)return Math.max(...t);let e=-Infinity;for(const r of t)e=Math.max(e,r);return e}function p(t){return[...new Set(t)]}function g(t){return void 0===t}function x(t,e){let r=new Map,n={};for(;v(r,n,t,e);)for(let s=0;s<t;s++)r.has(s)||d(s,r,n,t,e);return r}function v(t,e,r,n){let s=[],i=Infinity;for(let n=0;n<r;n++)t.has(n)?e[n]=Infinity:(e[n]=0,s.push(n));for(;s.length;){const r=s.shift();if(e[r]>=i)break;const l=n[r];for(let n=0;n<l.length;n++){const o=t.get(l[n]);g(o)?i=e[r]+1:Infinity===e[o]&&(e[o]=e[r]+1,s.push(o))}}return i<Infinity}function d(t,e,r,n,s){const i=s[t];for(let l=0;l<i.length;l++){const o=i[l],h=e.get(o);if(g(h))return e.set(t,o),e.set(o,t),!0;if(r[h]===r[t]+1&&d(h,e,r,n,s))return e.set(t,o),e.set(o,t),!0}return r[t]=Infinity,!1}function y(t,e,r){e.add(t);const n=r[t]||[];for(let t=0;t<n.length;t++)e.has(n[t])||y(n[t],e,r)}function m(t,e,r){e.add(t);for(let n=0;n<r.length;n++)r[t][n]&&!e.has(n)&&y(n,e,r)}const M=function(){let t=null;return function(e,r){let n=Math.floor((e+r)/2);return n===t&&(n=Math.ceil((e+r)/2)),t=n,n}}();function A(t,e){return t=Math.ceil(t),e=Math.floor(e),Math.floor(t+Math.random()*(e-t))}function _(t,e){if(0===e)return 1n;const r=BigInt(e),n=BigInt(t);let s=1n,i=1n;for(let t=0n;t<r;t++)s*=n-t;for(let t=1n;t<=r;t++)i*=t;return s/i}class w{constructor(t,e=null,r=null){this.val=t,this.left=e,this.right=r,this.size=1}}class z{constructor(t=[],e=(t=>t)){this.keys=[...t],this.mapValueKey=e;for(let t=Math.floor((this.keys.length-2)/2);t>=0;t--)this.sink(t)}insert(t){this.keys.push(t),this.swim(this.keys.length-1)}exch(t,e){[this.keys[t],this.keys[e]]=[this.keys[e],this.keys[t]]}less(t,e){return this.mapValueKey(this.keys[t])-this.mapValueKey(this.keys[e])<0}swim(t){let e=Math.floor((t-1)/2);for(;e>=0&&this.less(e,t);)this.exch(t,e),t=e,e=Math.floor((e-1)/2)}sink(t){let e=this.keys.length,r=2*t+1;for(;r<e&&(r+1<e&&this.less(r,r+1)&&r++,this.less(t,r));)this.exch(t,r),t=r,r=2*r+1}peek(){return this.keys[0]}poll(){let t=this.peek();return this.exch(0,this.keys.length-1),this.keys.length=this.keys.length-1,this.sink(0),t}isEmpty(){return!this.keys.length}size(){return this.keys.length}}class N{constructor(t){this.next=this,this.prev=this,this.val=t}}class b{constructor(){const t=new V;this.nil=new N(t)}firstLevel(){return this.nil.next===this.nil&&this.insert(),this.nil.next}insert(){const t=new V,e=new N(t);return this.nil.next.prev=e,e.next=this.nil.next,this.nil.next=e,e.prev=this.nil,e.next!==this.nil&&(e.val.nil.below=e.next.val.nil,e.next.val.nil.above=e.val.nil),e}remove(t){t.prev=t.next}}class k{constructor(t){this.prev=this,this.next=this,this.above=null,this.below=null,this.val=t}}class V{constructor(){this.nil=new k}static insertAboveAfter(t,e,r){t.next=r.next,r.next.prev=t,r.next=t,e&&(e.above=t),t.prev=r,t.below=e}static remove(t){t.prev.next=t.next,t.next.prev=t.prev}}class q{constructor(t,e,r){this.arr=t,this.getLeafValue=e,this.getNotLeafValue=r;const n=t.length;this.tree=Array(4*n),this._build(0,0,n-1)}_build(t,e,r){if(e===r)return void(this.tree[t]={l:e,r:r,v:this.getLeafValue(this.arr[e])});let n=Math.floor((e+r)/2);this._build(2*t+1,e,n),this._build(2*t+2,n+1,r),this.tree[t]={l:e,r:r,v:this.getNotLeafValue(this.tree[2*t+1].v,this.tree[2*t+2].v)}}_update(t,e,r){const{l:n,r:s}=this.tree[t];if(e<n||e>s)return;if(n===s)return void(n===e&&(this.tree[t].v=this.getLeafValue(r)));let i=Math.floor((n+s)/2);this._update(e>i?2*t+2:2*t+1,e,r),this.tree[t].v=this.getNotLeafValue(this.tree[2*t+1].v,this.tree[2*t+2].v)}}exports.ListNode=s,exports.MaxArr=class extends q{constructor(t,e=(t=>t)){super(t,t=>t,(t,r)=>e(t)-e(r)>=0?t:r),this.mapValueKey=e}_query(t,e,r){const{l:n,r:s,v:i}=this.tree[t];if(e<=n&&r>=s)return i;if(r<n||e>s)return;let l=this._query(2*t+1,e,r),o=this._query(2*t+2,e,r);return void 0===l?o:void 0===o?l:this.getNotLeafValue(l,o)}query(t=0,e=this.arr.length-1){return this._query(0,t,e)}update(t,e){this.arr[t]=e,this._update(0,t,e)}},exports.MaxPQ=class extends z{max(){return this.peek()}delMax(){return this.poll()}},exports.MinPQ=class extends z{constructor(t=[],e=(t=>t)){super(t,t=>-1*e(t))}min(){return this.peek()}delMin(){return this.poll()}},exports.RBST=class{constructor(t=(t=>t)){this.root=null,this.mapValueKey=t}insertAsRoot(t,e){if(!e)return new w(t);const r=e.size+1,n=this.mapValueKey(t),[s,i]=this.split(n,e),l=new w(t,s,i);return l.size=r,l}split(t,e){if(!e)return[null,null];if(this.mapValueKey(e.val)>t){let[r,n]=this.split(t,e.left);return e.left=n,e.size-=r?r.size:0,[r,e]}{let[r,n]=this.split(t,e.right);return e.right=r,e.size-=n?n.size:0,[e,n]}}join(t,e){const r=t?t.size:0,n=e?e.size:0,s=r+n;return s?A(0,n+r)<r?(t.right=this.join(t.right,e),t.size=s,t):(e.left=this.join(t,e.left),e.size=s,e):null}_insert(t,e){if(!e)return this.insertAsRoot(t,e);const r=e.size;return A(0,r+1)===r?this.insertAsRoot(t,e):(this.mapValueKey(t)<this.mapValueKey(e.val)?e.left=this._insert(t,e.left):e.right=this._insert(t,e.right),e.size++,e)}insert(t){this.root=this._insert(t,this.root)}search(t){let e=this.root;for(;e;){const r=this.mapValueKey(e.val);if(t===r)return e.val;e=t<r?e.left:e.right}return null}remove(t){if(null===this.search(t))return;let e,r=this.root,n=null;for(;r;){const s=this.mapValueKey(r.val);if(t===s){if(n){const t=this.join(r.left,r.right);n[e]=t}else this.root=this.join(r.left,r.right);return}t<s?(n=r,e="left",r.size--,r=r.left):(n=r,e="right",r.size--,r=r.right)}return null}findKMax(t){const e=this.root;if(!e)return null;const r=e.size;if((t=r+1-t)>r)return null;let n=e,s=0;for(;n;){var i;const e=s+((null==(i=n.left)?void 0:i.size)||0)+1;if(t===e)return n.val;t<e?n=n.left:(s=e,n=n.right)}return null}},exports.SkipList=class{constructor(t=(t=>t)){this.dl=new b,this.mapValueKey=t}_search(t,e=this.dl.firstLevel(),r=e.val.nil){const n=e.val.nil;for(r=r.next;r!==n&&this.mapValueKey(r.val)<=t;)r=r.next;return(r=r.prev).below?this._search(t,e.next,r=r.below):{dlNode:e,qlNode:r}}search(t){const{qlNode:e}=this._search(t);return this.mapValueKey(e.val)===t?e.val:null}insert(t){let{qlNode:e,dlNode:r}=this._search(this.mapValueKey(t));const n=new k(t);V.insertAboveAfter(n,null,e);let s=n;for(;Math.random()<.5;){const n=new k(t);for(;e!==r.val.nil&&!e.above;)e=e.prev;if(e===r.val.nil&&r.prev===this.dl.nil)r=this.dl.insert(),e=r.val.nil;else{if(!e.above)throw new Error("qlNode above must not be null");e=e.above,r=r.prev}V.insertAboveAfter(n,s,e),s=n}}min(){return this.dl.nil.prev.val.nil.next.val}max(){return this.dl.nil.prev.val.nil.prev.val}remove(t){let{qlNode:e}=this._search(t);if(this.mapValueKey(e.val)===t)for(V.remove(e);e.above;)e=e.above,V.remove(e)}},exports.SumArr=class extends q{constructor(t){super(t,t=>t,(t,e)=>t+e)}_query(t,e,r){const{l:n,r:s,v:i}=this.tree[t];if(e<=n&&r>=s)return i;if(r<n||e>s)return 0;let l=this._query(2*t+1,e,r),o=this._query(2*t+2,e,r);return this.getNotLeafValue(l,o)}query(t=0,e=this.arr.length-1){return this._query(0,t,e)}update(t,e){this.arr[t]=e,this._update(0,t,e)}},exports.TreeNode=t,exports.UnionFind=class{constructor(t){this.fatherMap=Array(t).fill(-1),this.sizeMap=Array(t).fill(1),this.size=t}find(t){return-1===this.fatherMap[t]?t:(this.fatherMap[t]=this.find(this.fatherMap[t]),this.fatherMap[t])}isSameSet(t,e){return this.find(t)===this.find(e)}union(t,e){const r=this.find(t),n=this.find(e);r!==n&&(this.sizeMap[r]>this.sizeMap[n]?(this.fatherMap[n]=r,this.sizeMap[n]=this.sizeMap[n]+this.sizeMap[r]):(this.fatherMap[r]=n,this.sizeMap[r]=this.sizeMap[n]+this.sizeMap[r]))}},exports.ValueArr=class extends q{constructor(t){super(u(p(t)),()=>0,(t,e)=>t+e)}_query(t,e,r){const{l:n,r:s,v:i}=this.tree[t],l=this.arr[n],o=this.arr[s];return e<=l&&r>=o?i:e>o||r<l?0:this._query(2*t+1,e,r)+this._query(2*t+2,e,r)}query(t,e){return this._query(0,t,e)}_insert(t,e){const r=this.tree[t],{l:n,r:s}=r;this.arr[n]<=e&&this.arr[s]>=e&&(r.v++,n<s&&(this._insert(2*t+1,e),this._insert(2*t+2,e)))}insert(t){this._insert(0,t)}},exports.bit=function(t,e){for(t<0&&(t*=-1);e>0;)t=Math.floor(t/2),e--;return t%2},exports.bitCount=function(t){let e=0;for(;t;)t%2==1&&e++,t=Math.floor(t/2);return e},exports.c=_,exports.cm=function(t,e){const r=BigInt(10**9+7);return Number(_(t,e)%r)},exports.countOfUniqueA=function(t){let e=0;if(t.length<=1)return 0;u(t);let r=t[0];for(let n=1;n<t.length;n++)r++,r<t[n]?r=t[n]:e+=r-t[n];return e},exports.countOfUniqueD=function(t){let e=0;if(t.length<=1)return 0;a(t);let r=t[0];for(let n=1;n<t.length;n++)r--,r>t[n]?r=t[n]:e+=t[n]-r;return e},exports.gcd=function t(e,r){return 0===r?e:t(r,e%r)},exports.getConnectedNumByAdjArr=function(t,e=t.length){let r=new Set,n=0;for(let s=0;s<e;s++)r.has(s)||(n++,y(s,r,t));return n},exports.getConnectedNumByAdjMatrix=function(t){let e=0;const r=t.length;let n=new Set;for(let s=0;s<r;s++)n.has(s)||(e++,m(s,n,t));return e},exports.getPalindromeArr=function(t){let e=2*t.length+1,r=Array(e).fill("|");for(let e=0;e<t.length;e++)r[2*e+1]=t[e];let n=Array(e).fill(0),s=0,i=0;for(;s<e;){for(;s-(i+1)>=0&&s+(i+1)<e&&r[s-i-1]===r[s+i+1];)i++;n[s]=i;let t=s,l=i;for(s++;s<=t+l;){let e=t+l-s;if(n[2*t-s]===e){i=e;break}n[2*t-s]>e?(n[s]=t+l-s,s++):(n[s]=n[2*t-s],s++)}}let l=Array(t.length).fill(0);for(let t=0;t<l.length;t++)l[t]=n[2*t+1];return l},exports.hopcroftKarp=x,exports.init2Array=function(t,e,r=0){const n=[];for(let s=0;s<t;s++)n[s]=Array(e).fill(r);return n},exports.initArray=function t(e){if(Number.isInteger(e))return Array(e).fill(0);if(!Array.isArray(e))throw new Error("dimension sould be int or int array");return 1===e.length?Array(e[0]).fill(0):Array.from(Array(e[0]),()=>[...t(e.slice(1))])},exports.inorder=function(t,e){if(!t)return;let r=new Map,n=[t];for(;n.length;){let t=f(n);r.get(t)?(n.pop(),e(t),t.right&&n.push(t.right)):(r.set(t,!0),t.left&&n.push(t.left))}},exports.intersect=function(t,e){const r=new Set(t);let n=[];for(let t=0;t<e.length;t++){const s=e[t];r.has(s)&&n.push(s)}return n},exports.listNode=o,exports.max=c,exports.maxIntervalDisjoint=function(t){if(u(t,t=>t[1]),!t.length)return 0;let e=1,[,r]=t[0];for(let n=1;n<t.length;n++){const s=t[n];s[0]>r&&(e++,r=s[1])}return e},exports.medium=M,exports.mergeArray=function(t){if(!t.length)return[];t.sort((t,e)=>t[0]-e[0]);let e=t[0],r=[];for(let n=1;n<t.length;n++)t[n][0]<=e[1]?e=[e[0],Math.max(t[n][1],e[1])]:(r.push(e),e=t[n]);return r.push(e),r},exports.min=function(...t){if(!Array.isArray(t[0]))return Math.min(...t);if((t=t[0]).length<=1e4)return Math.min(...t);let e=Infinity;for(const r of t)e=Math.min(e,r);return e},exports.minCoverVertices=function(t,e,r){const n=x(t,e);void 0===r&&(r=c(e.map(t=>c(t)))+1);let s=[],i=new Set;for(let e=0;e<t;e++)n.has(e)||(i.add(e),s.push(e));for(;s.length;)s.splice(0).forEach(t=>{let r=e[t];for(let t=0;t<r.length;t++){let e=r[t];if(!i.has(e)){i.add(e);const t=n.get(e);s.push(t),i.add(t)}}});let l=[];for(let e=0;e<t;e++)i.has(e)||l.push(e);for(let e=t;e<r;e++)i.has(e)&&l.push(e);return l},exports.minIntervalCover=function(t){if(u(t,t=>t[0]),!t.length)return 0;let e=1,[,r]=t[0];for(let n=1;n<t.length;n++)t[n][0]<=r?r=Math.max(r,t[n][1]):(e++,r=t[n][1]);return e},exports.mod=function(t,e){const r=t%e;return r<0?r+e:r},exports.nextPermutation=function(t){let e=t.length-1;for(;e>=1&&t[e]<=t[e-1];)e--;if(0===e)return t.reverse();e--;let r=t[e+1],n=e+1;for(let s=t.length-1;s>e;s--)t[s]>t[e]&&t[s]<r&&(r=Math.min(t[s],r),n=s);[t[e],t[n]]=[t[n],t[e]];for(let r=e+1;r<=Math.floor((e+t.length)/2);r++)[t[r],t[t.length+e-r]]=[t[t.length+e-r],t[r]];return t},exports.postorder=function(t,e){if(!t)return;let r=new Map,n=[t];for(;n.length;){let t=f(n);r.get(t)?(n.pop(),e(t)):(r.set(t,!0),t.right&&n.push(t.right),t.left&&n.push(t.left))}},exports.prevorder=function(t,e){if(!t)return;let r=[t],n=new Map;for(n.set(t,null);r.length;){let t=r.pop();e(t,n.get(t)),t.right&&(n.set(t.right,t),r.push(t.right)),t.left&&(n.set(t.left,t),r.push(t.left))}},exports.random=A,exports.reverse=function(t,e=0,r=t.length-1){for(let n=e;n<(e+r)/2;n++){let s=t[n];t[n]=t[e+r-n],t[e+r-n]=s}return t},exports.rotate90=function([t,e],[r,n]){return[r+n-e,t-r+n]},exports.rotateCw90=function([t,e],[r,n]){return[e-n+r,r-t+n]},exports.sortA=u,exports.sortD=a,exports.sum=function(t){return t.reduce((t,e)=>t+e,0)},exports.toIndexArr=function(t){let e=[];for(let r=0;r<t.length;r++)e[r]={index:r,value:t[r]};return e},exports.treeNode=n,exports.unique=p;
//# sourceMappingURL=algm.cjs.production.min.js.map
