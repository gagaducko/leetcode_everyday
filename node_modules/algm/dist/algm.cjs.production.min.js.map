{"version":3,"file":"algm.cjs.production.min.js","sources":["../src/treeNode.ts","../src/listNode.ts","../src/array.ts","../src/hopcroftKarp.ts","../src/graph.ts","../src/interval.ts","../src/math.ts","../src/rbst.ts","../src/pq.ts","../src/skiplist.ts","../src/segment.ts","../src/unionFind.ts","../src/manacher.ts","../src/tree.ts"],"sourcesContent":["export class TreeNode<T = number> {\n  constructor(\n    public val: T,\n    public left: TreeNode<T> | null = null,\n    public right: TreeNode<T> | null = null\n  ) {}\n}\n\n/**\n * Encodes a tree to a single string.\n *\n * @mermaid\n * graph LR\n *   1 --- 2\n *   1 --- 3\n *   3 --- 4\n *   3 --- 5\n * @example\n * ```js\n * serialize(root) // => '[1,2,3,null,null,4,5]'\n * ```\n */\nfunction serialize<T = number>(root: TreeNode<T> | null): string {\n  if (!root) {\n    return JSON.stringify([])\n  }\n  let arr: (T | null)[] = []\n  let queue: (TreeNode<T> | null)[] = [root]\n  while (queue.length) {\n    let node = queue.shift()\n    if (node) {\n      arr.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    } else {\n      arr.push(null)\n    }\n  }\n  let i = arr.length - 1\n  while (arr[i] === null) {\n    i--\n  }\n  arr.length = i + 1\n  return JSON.stringify(arr)\n}\n\nfunction serializeArr<T = number>(arr: (TreeNode<T> | null)[]): string {\n  const outArr = []\n  for (let i = 0; i < arr.length; i++) {\n    outArr.push(serialize(arr[i]))\n  }\n  return '[' + outArr.join(',') + ']'\n}\n\n/**\n * Decodes your encoded data to tree.\n */\nfunction deserialize<T = number>(originData: string): TreeNode<T> | null {\n  const data = JSON.parse(originData)\n  if (!data.length) {\n    return null\n  }\n  let val = data.shift() as T\n  let root = new TreeNode(val)\n  let queue: TreeNode<T>[] = [root]\n  while (queue.length) {\n    let node = queue.shift() as TreeNode<T>\n    let leftVal = data.shift()\n    if (leftVal === undefined) {\n      return root\n    }\n    if (leftVal !== null) {\n      let left = new TreeNode(leftVal)\n      node.left = left\n      queue.push(left)\n    }\n    let rightVal = data.shift()\n    if (rightVal === undefined) {\n      return root\n    }\n    if (rightVal !== null) {\n      let right = new TreeNode(rightVal)\n      node.right = right\n      queue.push(right)\n    }\n  }\n  return root\n}\n\nfunction deserializeArr<T = number>(\n  originData: string\n): (TreeNode<T> | null)[] {\n  const data: (T | null)[][] = JSON.parse(originData)\n  if (!data.length) {\n    return []\n  }\n  let outArr: (TreeNode<T> | null)[] = []\n  for (let i = 0; i < data.length; i++) {\n    outArr.push(deserialize(JSON.stringify(data[i])))\n  }\n  return outArr\n}\n\nexport { serialize, deserialize, serializeArr, deserializeArr }\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n","export class ListNode<T = number> {\n  constructor(\n    public val: T | undefined = undefined,\n    public next: ListNode<T> | null = null\n  ) {}\n}\n/**\n * Encodes a list to a single string.\n *\n * @mermaid\n * graph LR\n *   1 --- 2\n *   2 --- 3\n *   3 --- 4\n *   4 --- 5\n * @example\n * ```js\n * serialize(root) // => '[1,2,3,4,5]'\n * ```\n */\nexport function serialize<T = number>(head: ListNode<T> | null): string {\n  if (!head) {\n    return JSON.stringify([])\n  }\n  let arr = []\n  let node: ListNode<T> | null = head\n  while (node) {\n    arr.push(node.val)\n    node = node.next\n  }\n  return JSON.stringify(arr)\n}\n\nexport function serializeArr<T = number>(arr: (ListNode<T> | null)[]): string {\n  let out = []\n  for (let i = 0; i < arr.length; i++) {\n    out.push(serialize(arr[i]))\n  }\n  return '[' + out.join(',') + ']'\n}\n\n/**\n * Decodes your encoded data to list.\n */\nexport function deserialize<T = number>(\n  originData: string\n): ListNode<T> | null {\n  const data = JSON.parse(originData)\n  let header = new ListNode<T>()\n  let node = header\n  for (let i = 0; i < data.length; i++) {\n    node.next = new ListNode(data[i])\n    node = node.next\n  }\n  return header.next\n}\n\nexport function deserializeArr<T = number>(\n  originData: string\n): (ListNode<T> | null)[] {\n  const arr: T[][] = JSON.parse(originData)\n  let out: (ListNode<T> | null)[] = []\n  for (let i = 0; i < arr.length; i++) {\n    out.push(deserialize(JSON.stringify(arr[i])))\n  }\n  return out\n}\n/**\n * reverse a list\n */\nexport function reverseList<T>(head: ListNode<T> | null): ListNode<T> | null {\n  if (!head) {\n    return null\n  }\n  let prev = null\n  let cur: ListNode<T> | null = head\n  while (cur) {\n    let next: ListNode<T> | null = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n  return prev\n}\n","/**\n * Initializes an array with initial value of 0\n * @return return the new array\n * @category array\n * @example\n * ```js\n * initArray(3) // => [0,0,0]\n * initArray([3,2]) // => [[0,0],[0,0],[0,0]]\n * ```\n */\nexport function initArray(dimension: number | number[]): any[] {\n  if (Number.isInteger(dimension)) {\n    return Array(dimension).fill(0)\n  }\n  if (!Array.isArray(dimension)) {\n    throw new Error('dimension sould be int or int array')\n  }\n  if (dimension.length === 1) {\n    let len = dimension[0]\n    return Array(len).fill(0)\n  }\n\n  let len = dimension[0]\n  return Array.from(Array(len), () => [...initArray(dimension.slice(1))])\n}\n/**\n * Initializes a two-dimensional array\n * @param m\n * @param n\n * @param value the default value of element\n * @category array\n * @return return the new array\n * @example\n * ```js\n * init2Array(2,3) // => [[0,0,0],[0,0,0]]\n * ```\n */\nexport function init2Array(m: number, n: number, value = 0): number[][] {\n  const arr: number[][] = []\n  for (let i = 0; i < m; i++) {\n    arr[i] = Array(n).fill(value)\n  }\n  return arr\n}\n\n/**\n * merge all overlapped intervals\n * @param intervals\n * @category array\n * @example\n * ```js\n * mergeArray([[0,1],[1,2],[3,4]]) // => [[0,2],[3,4]]\n * ```\n */\nexport function mergeArray(intervals: number[][]) {\n  if (!intervals.length) {\n    return []\n  }\n  intervals.sort((arr1, arr2) => arr1[0] - arr2[0])\n  let prev = intervals[0]\n  let result = []\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] <= prev[1]) {\n      prev = [prev[0], Math.max(intervals[i][1], prev[1])]\n    } else {\n      result.push(prev)\n      prev = intervals[i]\n    }\n  }\n  result.push(prev)\n  return result\n}\n\n/**\n * Intersection of two array\n * @param {any[]} arr1\n * @param {any[]} arr2\n * @return {any[]}\n * @category array\n * @example\n * ```js\n * intersect([1,2],[2,3]) // => [2]\n * ```\n */\nexport function intersect<T>(arr1: T[], arr2: T[]): T[] {\n  const set = new Set(arr1)\n  let result = []\n\n  for (let i = 0; i < arr2.length; i++) {\n    const e = arr2[i]\n    if (set.has(e)) {\n      result.push(e)\n    }\n  }\n  return result\n}\n\n/**\n *  the min sum to make array unique by subtracting of the element\n * @param arr an array of int\n * @category array\n * @example\n * ```js\n * countOfUniqueD([3,3,1]) // => 1,the unique array should be [3,2,1], 3->2\n * countOfUniqueD([3,3,3]) // => 3,the unique array should be [3,2,1], 3->2, 3->1\n * ```\n */\nexport function countOfUniqueD(arr: number[]): number {\n  let result = 0\n  if (arr.length <= 1) {\n    return 0\n  }\n  sortD(arr)\n  let t = arr[0]\n  for (let i = 1; i < arr.length; i++) {\n    t--\n    if (t > arr[i]) {\n      t = arr[i]\n    } else {\n      result += arr[i] - t\n    }\n  }\n  return result\n}\n\n/**\n * the min sum to make array unique by increasing the element\n * @param arr an array of int\n * @category array\n * @example\n * ```js\n * countOfUniqueA([1,1,2]) // => 2,the unique array should be [1,2,3]\n * countOfUniqueA([0,2,2,2,3]) // => 5 ,the unique array should be [0,2,3,4,5], 2->4,2->5\n * ```\n */\nexport function countOfUniqueA(arr: number[]) {\n  let result = 0\n  if (arr.length <= 1) {\n    return 0\n  }\n  sortA(arr)\n  let t = arr[0]\n  for (let i = 1; i < arr.length; i++) {\n    t++\n    if (t < arr[i]) {\n      t = arr[i]\n    } else {\n      result += t - arr[i]\n    }\n  }\n  return result\n}\n\n/**\n * reverse the array from start to end\n * @category array\n * @example\n * ```js\n * reverse([2,3,4]) // => [4,3,2]\n * ```\n */\nexport function reverse<T>(arr: T[], start = 0, end = arr.length - 1): T[] {\n  for (let i = start; i < (start + end) / 2; i++) {\n    let t = arr[i]\n    arr[i] = arr[start + end - i]\n    arr[start + end - i] = t\n  }\n  return arr\n}\ninterface IndexObj<T> {\n  index: number\n  value: T\n}\n/**\n * return an index arr\n * @category array\n * @example\n * ```js\n * toIndexArr([1,2,3]) // => [{index:0,value:1},{index:1,value:2},{index:2,value:3}]\n * ```\n */\nexport function toIndexArr<T>(arr: T[]): IndexObj<T>[] {\n  let indexArr: IndexObj<T>[] = []\n  for (let i = 0; i < arr.length; i++) {\n    indexArr[i] = {\n      index: i,\n      value: arr[i],\n    }\n  }\n  return indexArr\n}\n\nfunction compare(v1: number | string, v2: number | string) {\n  if (typeof v1 !== typeof v2) {\n    throw new Error('the type of key should be the same')\n  }\n  if (typeof v1 !== 'string') {\n    return v1 - (v2 as number)\n  } else {\n    return v1.localeCompare(v2 as string)\n  }\n}\ntype GetCompareKey<T> = (a: T) => any\n/**\n * Sort the array in ascending order by key\n * @param  arr the array\n * @param  fn return the key to sort, default key is value\n * @param  fn2 if the key is equal, using the second key\n * @category array\n * @example\n * ```js\n * sortA([3,1,2]) // => [1,2,3]\n * sortA([{height:3},{height:2},{height:1}],x=>x.height) // => [{height:1},{height:2},{height:3}]\n * sortA(['ca','ba','bd']) // => ['ba','bd','ca']\n * ```\n */\nexport function sortA<T>(arr: T[], fn: GetCompareKey<T> = x => x, fn2 = fn) {\n  return arr.sort((x, y) => {\n    const key1 = fn(x)\n    const key2 = fn(y)\n    const r = compare(key1, key2)\n    if (r) {\n      return r\n    }\n    const key3 = fn2(x)\n    const key4 = fn2(y)\n    return compare(key3, key4)\n  })\n}\n/**\n * Sort the array in descending order by key\n * will change the origin array\n * @param  arr the array\n * @param  getCompareKey return the key to sort\n * @param  getCompareKey2 if the key is equal, using the second key\n * @category array\n * @example\n * ```js\n * sortD([3,1,2]) // => [3,2,1]\n * sortD([{height:3},{height:2},{height:1}],x=>x.height) // => [{height:3},{height:2},{height:1}]\n * sortD(['ca','ba','bd']) // => ['ca','bd','ba']\n * sortD([{value:1,index:1},{value:2,index:3},{value:2,index:2}],x=>x.value,x=>x.index)\n * // => [{value:2,index:3},{value:2,index:2},{value:1,index:1}]\n * ```\n */\nexport function sortD<T>(\n  arr: T[],\n  getCompareKey: GetCompareKey<T> = x => x,\n  getCompareKey2 = getCompareKey\n) {\n  return arr.sort((x, y) => {\n    const key1 = getCompareKey(x)\n    const key2 = getCompareKey(y)\n    const r = compare(key2, key1)\n    if (r) {\n      return r\n    }\n    const key3 = getCompareKey2(x)\n    const key4 = getCompareKey2(y)\n    return compare(key4, key3)\n  })\n}\n\n/**\n * Return the last value\n * @param arr the array\n * @category array\n * ```js\n * last([2,1,5]) // => 5\n * last([]) // => undefined\n * ```\n */\nexport function last<T>(arr: T[]): T {\n  return arr[arr.length - 1]\n}\ninterface PlainObj {\n  [key: string]: any\n}\n\n/**\n * Push a value to a property of the object\n * @example\n * ```js\n * const obj={}\n * push(obj,'key1','a')\n * push(obj,'key1','b')\n * push(obj,'key2','c')\n * console.log(obj) // => {key1:['a','b'],key2:['c']}\n * ```\n */\nexport function push(obj: PlainObj, key: string | number, item: any) {\n  if (!obj[key]) {\n    obj[key] = []\n  }\n  obj[key].push(item)\n}\n/**\n * Gets a unique key based on the parameter\n * ```js\n * key('abc','bd') // => 'abc#bd'\n * key(['a','b']) // => 'a#b'\n * ```\n */\nexport function key(\n  ...args: (number | string)[] | (number | string)[][]\n): string {\n  if (Array.isArray(args[0])) {\n    return args[0].join('#')\n  }\n  return args.join('#')\n}\n\n/**\n * compute the sum of an array\n * @category array\n * @example\n * ```js\n * sum([1,2,3]) // => 6\n * sum([]) // => 0\n * ```\n */\nexport function sum(arr: number[]) {\n  return arr.reduce((prev, cur) => prev + cur, 0)\n}\n\n/**\n * Get the max value\n * @category array\n * @example\n * ```js\n * max(1,3,2) // => 3\n * max([1,3,2]) // => 3\n * ```\n */\nexport function max(...arg: number[] | number[][]): number {\n  if (!Array.isArray(arg[0])) {\n    return Math.max(...(arg as number[]))\n  }\n\n  arg = arg[0]\n\n  if (arg.length <= 10000) {\n    return Math.max(...arg)\n  }\n\n  let max = -Infinity\n\n  for (const num of arg) {\n    max = Math.max(max, num)\n  }\n\n  return max\n}\n\n/**\n * Get the min value\n * @category array\n * @example\n * ```js\n * min(1,3,2) // => 1\n * min([1,3,2]) // => 1\n * ```\n */\nexport function min(...arg: number[] | number[][]): number {\n  if (!Array.isArray(arg[0])) {\n    return Math.min(...(arg as number[]))\n  }\n\n  arg = arg[0]\n\n  if (arg.length <= 10000) {\n    return Math.min(...arg)\n  }\n\n  let min = Infinity\n\n  for (const num of arg) {\n    min = Math.min(min, num)\n  }\n\n  return min\n}\n\n/**\n * return a new arr that does not contains duplicate elements.\n * @category array\n * @example\n * ```js\n * unique([1,1,2,2,2,6,1]) //=> [1,2,6]\n * ```\n */\nexport function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)]\n}\n","/**\n * check if the value is `undefined`\n */\nfunction isNil(value: any): value is undefined {\n  return value === undefined\n}\ninterface DistMap {\n  [key: string]: number\n}\n/**\n * bipartite matching algorithms\n *\n * the [Hopcroft–Karp algorithm](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) is an algorithm that takes as input a bipartite graph and produces as output a maximum cardinality matching\n *\n * bipartite graph contains two vertex set X and Y\n * @param m the number of X\n * @param adj the adjacency array of X\n * @category Graph\n * @example\n * ```js\n * hopcroftKarp(5,[[5, 6], [5, 9], [7, 8], [5, 9], [6, 8]])\n * // => Map(10){ 0=>6,1=>9,2=>7,3=>5,4=>8,6=>0,7=>2,8=>4,9=>1 }\n * ```\n */\nexport function hopcroftKarp(m: number, adjArr: number[][]) {\n  // record the matching vertices\n  let map = new Map<number, number>()\n  let dist: DistMap = {}\n  while (bfs(map, dist, m, adjArr)) {\n    // dfs stage\n    for (let i = 0; i < m; i++) {\n      // the augmenting-path start from a unmatched vertice\n      if (!map.has(i)) {\n        dfs(i, map, dist, m, adjArr)\n      }\n    }\n  }\n  return map\n}\n/**\n * compute the shortest distance of all the vertices in X\n * @param map record the matching vertices\n * @param dist the distance map of the vertices in X\n * @param m the number of X\n * @param adjArr the adjacency array of X\n */\nfunction bfs(\n  map: Map<number, number>,\n  dist: DistMap,\n  m: number,\n  adjArr: number[][]\n) {\n  let queue: number[] = []\n  // record the shortest length of augmenting-path\n  // in fact the shortest length is shortDis*2-1\n  let shortDis = Infinity\n  // init the distance of vertices in every bfs stage\n  // the distance is 0 when the vertice do not match, or that is Infinity\n  for (let i = 0; i < m; i++) {\n    if (!map.has(i)) {\n      dist[i] = 0\n      queue.push(i)\n    } else {\n      dist[i] = Infinity\n    }\n  }\n\n  while (queue.length) {\n    const node = queue.shift()!\n    // this ensure all the augmenting-path length in the next dfs stage equal shortDis\n    if (dist[node] >= shortDis) {\n      break\n    }\n    const adjNodes = adjArr[node]\n    for (let i = 0; i < adjNodes.length; i++) {\n      const adjNode = adjNodes[i]\n      const nextNode = map.get(adjNode)\n      if (isNil(nextNode)) {\n        // find a augmenting-path\n        shortDis = dist[node] + 1\n      } else if (dist[nextNode] === Infinity) {\n        dist[nextNode] = dist[node] + 1\n        queue.push(nextNode)\n      }\n    }\n  }\n  return shortDis < Infinity\n}\nfunction dfs(\n  node: number,\n  map: Map<number, number>,\n  dist: DistMap,\n  m: number,\n  adjArr: number[][]\n): boolean {\n  const adjNodes = adjArr[node]\n  for (let i = 0; i < adjNodes.length; i++) {\n    const adjNode = adjNodes[i]\n    const nextNode = map.get(adjNode)\n    //find a augmenting-path\n    if (isNil(nextNode)) {\n      map.set(node, adjNode)\n      map.set(adjNode, node)\n      return true\n    } else if (dist[nextNode] === dist[node] + 1) {\n      if (dfs(nextNode, map, dist, m, adjArr)) {\n        map.set(node, adjNode)\n        map.set(adjNode, node)\n        return true\n      }\n    }\n  }\n  // mark this vertice has fail,so is will not visit in current dfs stage\n  dist[node] = Infinity\n  return false\n}\n","import { hopcroftKarp } from './hopcroftKarp'\nimport { max } from './index'\n/**\n * Calculate the connectivity degree according to the undirected graph adjacency array.\n * @param {number[][]} adjArr adjacency array\n * @param {number} n vertex number\n * @category Graph\n * @mermaid\n * graph LR\n *   0 --- 4\n *   1 --- 2\n *   2 --- 3\n * @example\n * ```js\n * getConnectedNumByAdjArr([[4],[2],[1,3],[2],[0]]) // => 2\n * ```\n */\nexport function getConnectedNumByAdjArr(\n  adjArr: number[][],\n  n: number = adjArr.length\n) {\n  let set: Set<number> = new Set()\n  let num = 0\n  for (let i = 0; i < n; i++) {\n    if (!set.has(i)) {\n      num++\n      dfs(i, set, adjArr)\n    }\n  }\n  return num\n}\nfunction dfs(node: number, set: Set<number>, adjArr: number[][]) {\n  set.add(node)\n  const adjNodes: number[] = adjArr[node] || []\n  for (let i = 0; i < adjNodes.length; i++) {\n    if (!set.has(adjNodes[i])) {\n      dfs(adjNodes[i], set, adjArr)\n    }\n  }\n}\n\n/**\n * Calculate the connectivity degree according to the undirected graph adjacency matrix.\n * @category Graph\n * @param {number[][]} adjMatrix 邻接矩阵\n */\nexport function getConnectedNumByAdjMatrix(adjMatrix: number[][]) {\n  let num = 0\n  const n = adjMatrix.length\n  let set: Set<number> = new Set()\n  for (let i = 0; i < n; i++) {\n    if (!set.has(i)) {\n      num++\n      dfs2(i, set, adjMatrix)\n    }\n  }\n  return num\n}\n\nfunction dfs2(index: number, set: Set<number>, isConnected: number[][]) {\n  set.add(index)\n  for (let j = 0; j < isConnected.length; j++) {\n    if (isConnected[index][j] && !set.has(j)) {\n      dfs(j, set, isConnected)\n    }\n  }\n}\n\n/**\n * bipartite graph contains two vertex set X and Y\n * Reference:https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)\n * @param m the number of set X\n * @param adjArr the adjacency array of X\n * @param n the number of set Y\n */\nexport function minCoverVertices(m: number, adjArr: number[][], n?: number) {\n  const map = hopcroftKarp(m, adjArr)\n  if (n === undefined) {\n    n = max(adjArr.map(edge => max(edge))) + 1\n  }\n\n  let arr = []\n  let set = new Set()\n  for (let i = 0; i < m; i++) {\n    // find not matched vertex in m\n    if (!map.has(i)) {\n      set.add(i)\n      arr.push(i)\n    }\n  }\n  let isInX = true\n  while (arr.length) {\n    if (isInX) {\n      const copyArr = arr.splice(0)\n      copyArr.forEach(x => {\n        let adjVertices = adjArr[x]\n        for (let i = 0; i < adjVertices.length; i++) {\n          let y = adjVertices[i]\n          if (!set.has(y)) {\n            set.add(y)\n            const newX = map.get(y)\n            arr.push(newX)\n            set.add(newX)\n          }\n        }\n      })\n    }\n  }\n  let coverVertices = []\n  for (let i = 0; i < m; i++) {\n    if (!set.has(i)) {\n      coverVertices.push(i)\n    }\n  }\n  for (let i = m; i < n!; i++) {\n    if (set.has(i)) {\n      coverVertices.push(i)\n    }\n  }\n  return coverVertices\n}\n","import { sortA } from './array'\n/**\n * minimum number of intervals to cover the target interval\n * @category interval\n */\nexport function minIntervalCover(intervals: number[][]) {\n  sortA(intervals, v => v[0])\n  if (!intervals.length) {\n    return 0\n  }\n  let c = 1\n  let [, right] = intervals[0]\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] <= right) {\n      right = Math.max(right, intervals[i][1])\n    } else {\n      c++\n      right = intervals[i][1]\n    }\n  }\n  return c\n}\n\n/**\n *\n * @param {number[][]} intervals\n * @category interval\n */\nexport function maxIntervalDisjoint(intervals: number[][]) {\n  sortA(intervals, v => v[1])\n\n  if (!intervals.length) {\n    return 0\n  }\n  let c = 1\n  let [, right] = intervals[0]\n\n  for (let i = 1; i < intervals.length; i++) {\n    const interval = intervals[i]\n    if (interval[0] > right) {\n      c++\n      right = interval[1]\n    }\n  }\n  return c\n}\n/**\n * @category interval\n */\nexport const medium = (function() {\n  let lastValue: any = null\n  return function(left: number, right: number) {\n    let m = Math.floor((left + right) / 2)\n    if (m === lastValue) {\n      m = Math.ceil((left + right) / 2)\n    }\n    lastValue = m\n    return m\n  }\n})()\n","/**\n * Randomly returns integers in [min, max)\n * @category math\n * @example\n * ```js\n * random(1,2) // => 1\n * random(2,8) // => 4\n * ```\n */\nexport function random(min: number, max: number) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(min + Math.random() * (max - min))\n}\n/**\n * Next bigger permutation\n * @param arr\n * @category math\n * @example\n * ```js\n * nextPermutation([1,2,3,4]) // => [1,2,4,3]\n * nextPermutation([4,3,2,1]) // => [1,2,3,4]\n * ```\n */\nexport function nextPermutation(arr: number[]) {\n  let i = arr.length - 1\n  while (i >= 1 && arr[i] <= arr[i - 1]) {\n    i--\n  }\n  if (i === 0) {\n    return arr.reverse()\n  }\n  i--\n  let min = arr[i + 1]\n  let index: number = i + 1\n  for (let j = arr.length - 1; j > i; j--) {\n    if (arr[j] > arr[i] && arr[j] < min) {\n      min = Math.min(arr[j], min)\n      index = j\n    }\n  }\n  ;[arr[i], arr[index]] = [arr[index], arr[i]]\n  for (let j = i + 1; j <= Math.floor((i + arr.length) / 2); j++) {\n    ;[arr[j], arr[arr.length + i - j]] = [arr[arr.length + i - j], arr[j]]\n  }\n  return arr\n}\n\n/**\n * Get the greatest common divisor of a and b\n * @category math\n * @example\n * ```js\n * gcd(4,2) // => 2\n * gcd(9,6) // => 3\n * ```\n */\nexport function gcd(a: number, b: number): number {\n  if (b === 0) {\n    return a\n  }\n  return gcd(b, a % b)\n}\n/**\n * The coordinates of the point [x,y] are rotated 90° anticlockwise around [x0,y0]\n * @category math\n * @example\n * ```js\n * rotate90([1,1],[2,2]) // => [1,3]\n * ```\n */\nexport function rotate90(\n  [x, y]: [number, number],\n  [x0, y0]: [number, number]\n): [number, number] {\n  return [x0 + y0 - y, x - x0 + y0]\n}\n\n/**\n * The coordinate of the point [x,y] are rotated 90° clockwise around [x0,y0]\n * @category math\n */\nexport function rotateCw90(\n  [x, y]: [number, number],\n  [x0, y0]: [number, number]\n): [number, number] {\n  return [y - y0 + x0, x0 - x + y0]\n}\n\n/**\n * Compute the number of permutations c(n,m)=n*(n-1)*...(n-m+1)/(m!)\n * @category math\n * @example\n * ```js\n * c(5,2) // => 10n\n * c(4,2) // => 6n\n * c(5,0) // => 1n\n * ```\n */\nexport function c(n: number, m: number): bigint {\n  if (m === 0) {\n    return 1n\n  }\n  const bm = BigInt(m)\n  const bn = BigInt(n)\n  let s = 1n\n  let s2 = 1n\n  for (let i = 0n; i < bm; i++) {\n    s *= bn - i\n  }\n  for (let i = 1n; i <= bm; i++) {\n    s2 *= i\n  }\n  return s / s2\n}\n\n/**\n * First compute the number of permutations c(n,m)=n*(n-1)*...(n-m+1)/(m!)\n * Then take the remainder of modulo 10 * * 9 + 7\n * @category math\n * @example\n * ```js\n * cm(5,2) // => 10\n * cm(4,2) // => 6\n * cm(5,0) // => 1\n * ```\n */\nexport function cm(n: number, m: number) {\n  const d = BigInt(10 ** 9 + 7)\n  return Number(c(n, m) % d)\n}\n\n/**\n * Returns the i th bit of the absolute value of num\n * @example\n * ```js\n * bit(9,1) // => 0\n * bit(4,2) // => 1\n * bit(3,0) // => 1\n * ```\n */\nexport function bit(num: number, i: number) {\n  if (num < 0) num = num * -1\n\n  while (i > 0) {\n    num = Math.floor(num / 2)\n    i--\n  }\n  return num % 2\n}\n\n/**\n * Get the number of 1 in the binary number\n * @param n the number\n * @example\n * ```js\n * bitCount(0) // => 0\n * bitCount(3) // => 2\n * bitCount(4) // => 1\n * ```\n */\nexport function bitCount(n: number) {\n  let c = 0\n\n  while (n) {\n    if (n % 2 === 1) {\n      c++\n    }\n\n    n = Math.floor(n / 2)\n  }\n\n  return c\n}\n\n/**\n * Compute the remainder of m mod n.\n * The remainder is greater than or equal to 0.\n * @param m\n * @param n\n * @example\n * ```js\n * mod(2,3) // => 2\n * mod(-2,3) // => 1\n * mod(3,2) // => 1\n * mod(-2,2) // => 0\n * ```\n */\nexport function mod(m: number, n: number) {\n  const remainder = m % n\n  if (remainder < 0) {\n    return remainder + n\n  }\n  return remainder\n}\n","import { random } from './math'\nclass RBSTNode<T> {\n  size = 1\n  constructor(\n    public val: T,\n    public left: RBSTNode<T> | null = null,\n    public right: RBSTNode<T> | null = null\n  ) {}\n}\ntype GetCompareKey = (a: any) => number\n/**\n * @category randomized binary search tree.\n * @description\n * a randomized binary search tree.\n * `search`, `insert`, `remove`, `find the k-th max value` achieve O(Logn) expected performance.\n * @example\n * ```js\n * const rbst = new RBST()\n * const arr=[1,7,3]\n * arr.forEach(v=>{\n *  rbst.insert(v)\n * })\n * rbst.search(3) // => 3\n * rbst.findKMax(1) // => 7\n * rbst.remove(3)\n * rbst.findKMax(2) // => 1\n *\n * ```\n */\nexport class RBST<T> {\n  root: RBSTNode<T> | null = null\n  mapValueKey: GetCompareKey\n  constructor(fn: GetCompareKey = x => x) {\n    this.mapValueKey = fn\n  }\n  /**\n   * Insert the item as the root of the tree.\n   * @param item\n   * @param tree\n   */\n  private insertAsRoot(item: T, tree: RBSTNode<T> | null): RBSTNode<T> {\n    if (!tree) {\n      return new RBSTNode(item)\n    }\n    const size = tree.size + 1\n    const key = this.mapValueKey(item)\n    const [left, right] = this.split(key, tree)\n    const newNode = new RBSTNode(item, left, right)\n    newNode.size = size\n    return newNode\n  }\n  /**\n   * Divide the tree into two parts :leftTree and rightTree.\n   * The leftTree key is less than the specified key,\n   * and the rightTree key is greater than the specified key.\n   * @param key\n   * @param tree\n   */\n  private split(\n    key: number,\n    tree: RBSTNode<T> | null\n  ): [RBSTNode<T> | null, RBSTNode<T> | null] {\n    if (!tree) {\n      return [null, null]\n    }\n    if (this.mapValueKey(tree.val) > key) {\n      let [leftTree, rightTree] = this.split(key, tree.left)\n      tree.left = rightTree\n      tree.size -= leftTree ? leftTree.size : 0\n      return [leftTree, tree]\n    } else {\n      let [leftTree, rightTree] = this.split(key, tree.right)\n      tree.right = leftTree\n      tree.size -= rightTree ? rightTree.size : 0\n      return [tree, rightTree]\n    }\n  }\n  /**\n   * merge the leftTree and rightTree into one tree.\n   * @param leftTree\n   * @param rightTree\n   */\n  private join(\n    leftTree: RBSTNode<T> | null,\n    rightTree: RBSTNode<T> | null\n  ): RBSTNode<T> | null {\n    const m = leftTree ? leftTree.size : 0\n    const n = rightTree ? rightTree.size : 0\n    const total = m + n\n    if (!total) return null\n    const r = random(0, n + m)\n    if (r < m) {\n      leftTree!.right = this.join(leftTree!.right, rightTree)\n      leftTree!.size = total\n      return leftTree\n    } else {\n      rightTree!.left = this.join(leftTree, rightTree!.left)\n      rightTree!.size = total\n      return rightTree\n    }\n  }\n  private _insert(item: T, tree: RBSTNode<T> | null) {\n    if (!tree) {\n      return this.insertAsRoot(item, tree)\n    }\n    const n = tree.size\n    const r = random(0, n + 1)\n    if (r === n) {\n      return this.insertAsRoot(item, tree)\n    } else if (this.mapValueKey(item) < this.mapValueKey(tree.val)) {\n      tree.left = this._insert(item, tree.left)\n    } else {\n      tree.right = this._insert(item, tree.right)\n    }\n    tree.size++\n    return tree\n  }\n  insert(item: T) {\n    this.root = this._insert(item, this.root)\n  }\n\n  search(key: number) {\n    let tree: RBSTNode<T> | null = this.root\n    while (tree) {\n      const curKey = this.mapValueKey(tree.val)\n      if (key === curKey) {\n        return tree.val\n      } else if (key < curKey) {\n        tree = tree.left\n      } else {\n        tree = tree.right\n      }\n    }\n    return null\n  }\n  remove(key: number) {\n    if (this.search(key) === null) {\n      return\n    }\n    let tree: RBSTNode<T> | null = this.root\n    let father = null\n    let p\n    while (tree) {\n      const curKey = this.mapValueKey(tree.val)\n      if (key === curKey) {\n        if (!father) {\n          this.root = this.join(tree.left, tree.right)\n        } else {\n          const newTree = this.join(tree.left, tree.right)\n          father[p as 'left' | 'right'] = newTree\n        }\n        return\n      } else if (key < curKey) {\n        father = tree\n        p = 'left'\n        tree.size--\n        tree = tree.left\n      } else {\n        father = tree\n        p = 'right'\n        tree.size--\n        tree = tree.right\n      }\n    }\n    return null\n  }\n  /**\n   * find the k-th max item\n   * @param k\n   */\n  findKMax(k: number) {\n    const root = this.root\n    if (!root) return null\n    const size = root.size\n    k = size + 1 - k\n    if (k > size) {\n      return null\n    }\n    let tree: RBSTNode<T> | null = root\n    let prevNum = 0\n    while (tree) {\n      const leftSize = tree.left?.size || 0\n      const curRank = prevNum + leftSize + 1\n      if (k === curRank) {\n        return tree.val\n      } else if (k < curRank) {\n        tree = tree.left\n      } else {\n        prevNum = curRank\n        tree = tree.right\n      }\n    }\n    return null\n  }\n}\n","type GetCompareKey<T> = (a: T) => number\n\nclass PQ<T> {\n  keys: T[]\n  mapValueKey: GetCompareKey<T>\n  constructor(keys: T[] = [], fn: GetCompareKey<T> = (x: any) => x) {\n    this.keys = [...keys]\n    this.mapValueKey = fn\n\n    for (let i = Math.floor((this.keys.length - 2) / 2); i >= 0; i--) {\n      this.sink(i)\n    }\n  }\n\n  insert(key: T) {\n    this.keys.push(key)\n    this.swim(this.keys.length - 1)\n  }\n\n  protected exch(i: number, j: number) {\n    ;[this.keys[i], this.keys[j]] = [this.keys[j], this.keys[i]]\n  }\n\n  protected less(i: number, j: number) {\n    return this.mapValueKey(this.keys[i]) - this.mapValueKey(this.keys[j]) < 0\n  }\n\n  protected swim(index: number) {\n    let father = Math.floor((index - 1) / 2)\n\n    while (father >= 0 && this.less(father, index)) {\n      this.exch(index, father)\n      index = father\n      father = Math.floor((father - 1) / 2)\n    }\n  }\n\n  protected sink(index: number) {\n    let len = this.keys.length\n    let j = index * 2 + 1\n\n    while (j < len) {\n      if (j + 1 < len && this.less(j, j + 1)) {\n        j++\n      }\n\n      if (this.less(index, j)) {\n        this.exch(index, j)\n        index = j\n        j = j * 2 + 1\n      } else {\n        break\n      }\n    }\n  }\n\n  protected peek() {\n    return this.keys[0]\n  }\n\n  protected poll() {\n    let head = this.peek()\n    this.exch(0, this.keys.length - 1)\n    this.keys.length = this.keys.length - 1\n    this.sink(0)\n    return head\n  }\n\n  isEmpty() {\n    return !this.keys.length\n  }\n\n  size() {\n    return this.keys.length\n  }\n}\n\n/**\n * @category priority queue\n * @example\n * ```js\n * const input =  [4, 3, 1]\n * const maxP = new MaxPQ(input)\n * maxP.max() //=> 4\n * maxP.insert(5)\n * maxP.max() //=> 5\n * maxP.insert(8)\n * maxP.max() //=> 8\n * maxP.delMax()\n * maxP.max() //=> 5\n * ```\n * Provide the specified key\n * ```js\n * const input = [{ name: 'xiao', age: 21 }, { name: 'wang', age: 22 }, { name: 'li', age: 25 }]\n * const maxP = new MaxPQ(input, v => v.age)\n * const m = maxP.max() //=> { name: 'li', age: 25 }\n * ```\n *\n */\nexport class MaxPQ<T> extends PQ<T> {\n  max() {\n    return this.peek()\n  }\n\n  delMax() {\n    return this.poll()\n  }\n}\n\n/**\n * @category priority queue\n * @example\n * ```js\n * const minPQ = new MinPQ([5, 1, 4, 2])\n * minPQ.min() // => 1\n * minPQ.delMin()\n * minPQ.min() // => 2\n * ```\n * Provide the specified key\n * ```js\n * const input = [{ name: 'xiao', age: 21 }, { name: 'wang', age: 22 }, { name: 'li', age: 25 }]\n * const minP = new MinPQ(input, v => v.age)\n * minP.min() // => { name: 'xiao', age: 21 }\n * ```\n */\nexport class MinPQ<T> extends PQ<T> {\n  constructor(keys: T[] = [], fn: GetCompareKey<T> = (x: any) => x) {\n    super(keys, x => -1 * fn(x))\n  }\n\n  min() {\n    return this.peek()\n  }\n\n  delMin() {\n    return this.poll()\n  }\n}\n","/**\n *   SkipList structure\n *   ---------------\n *  |     head(nil) |\n *  |       |       |\n *  |DoubleListNode | -> head(nil) - QuadListNode - QuadListNode - tail(nil)\n *  |       |       |      |                        |\n *  |DoubleListNode | -> head(nil) - QuadListNode - QuadListNode - tail(nil)\n *  |       |       |\n *  |     tail(nil) |\n *   ---------------\n *          ^\n *          |\n *          |\n *      DoubleList\n *\n *\n */\nexport class DoubleLinkNode<T> {\n  next: DoubleLinkNode<T>\n  prev: DoubleLinkNode<T>\n  val: QuadList<T>\n  constructor(val: QuadList<T>) {\n    this.next = this\n    this.prev = this\n    this.val = val\n  }\n}\nexport class DoubleLink<T> {\n  nil: DoubleLinkNode<T>\n  constructor() {\n    const qlList = new QuadList<T>()\n    this.nil = new DoubleLinkNode<T>(qlList)\n  }\n  firstLevel() {\n    if (this.nil.next === this.nil) {\n      this.insert()\n    }\n    return this.nil.next\n  }\n  insert() {\n    const ql = new QuadList<T>()\n    const node = new DoubleLinkNode(ql)\n    this.nil.next.prev = node\n    node.next = this.nil.next\n    this.nil.next = node\n    node.prev = this.nil\n    if (node.next !== this.nil) {\n      // link the above node and below node\n      node.val.nil.below = node.next.val.nil\n      node.next.val.nil.above = node.val.nil\n    }\n    return node\n  }\n  remove(node: DoubleLinkNode<T>) {\n    node.prev = node.next\n  }\n}\nclass QuadListNode<T> {\n  prev: QuadListNode<T>\n  next: QuadListNode<T>\n  above: QuadListNode<T> | null\n  below: QuadListNode<T> | null\n  val: T | undefined\n  constructor(val?: T) {\n    this.prev = this\n    this.next = this\n    this.above = null\n    this.below = null\n    this.val = val\n  }\n}\nclass QuadList<T> {\n  nil: QuadListNode<T>\n  constructor() {\n    this.nil = new QuadListNode()\n  }\n  static insertAboveAfter<T>(\n    newNode: QuadListNode<T>,\n    belowNode: QuadListNode<T> | null,\n    leftNode: QuadListNode<T>\n  ) {\n    newNode.next = leftNode.next\n    leftNode.next.prev = newNode\n    leftNode.next = newNode\n    if (belowNode) {\n      belowNode.above = newNode\n    }\n    newNode.prev = leftNode\n    newNode.below = belowNode\n  }\n  static remove<T>(node: QuadListNode<T>) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n  }\n}\ntype GetCompareKey = (a: any) => number\ninterface Position<T> {\n  dlNode: DoubleLinkNode<T>\n  qlNode: QuadListNode<T>\n}\n\n/**\n * a probabilistic data structure.\n * @category SkipList\n * @description\n * `search`, `insert`, `remove` achieve O(Logn) expected performance.\n * @example\n * ```js\n * const sl = new SkipList()\n * sl.insert(3)\n * sl.insert(1)\n * sl.insert(5)\n * sl.search(1) // => 1\n * ```\n */\nexport class SkipList<T> {\n  dl: DoubleLink<T>\n  mapValueKey: GetCompareKey\n  constructor(fn: GetCompareKey = x => x) {\n    this.dl = new DoubleLink()\n    this.mapValueKey = fn\n  }\n  private _search(\n    key: number,\n    dlNode: DoubleLinkNode<T> = this.dl.firstLevel(),\n    qlNode: QuadListNode<T> = dlNode.val.nil\n  ): Position<T> {\n    const tail = dlNode.val.nil\n    qlNode = qlNode.next\n    while (qlNode !== tail && this.mapValueKey(qlNode.val) <= key) {\n      qlNode = qlNode.next\n    }\n    qlNode = qlNode.prev\n\n    if (!qlNode.below) {\n      return {\n        dlNode,\n        qlNode,\n      }\n    }\n    qlNode = qlNode.below\n    return this._search(key, dlNode.next, qlNode)\n  }\n  search(key: number) {\n    const { qlNode } = this._search(key)\n    if (this.mapValueKey(qlNode.val) === key) {\n      return qlNode.val\n    }\n    return null\n  }\n  insert(value: T) {\n    let { qlNode, dlNode } = this._search(this.mapValueKey(value))\n    const newqlNode = new QuadListNode(value)\n    QuadList.insertAboveAfter(newqlNode, null, qlNode)\n    let belowNode = newqlNode\n    while (Math.random() < 0.5) {\n      const newqlNode = new QuadListNode(value)\n      while (qlNode !== dlNode.val.nil && !qlNode.above) {\n        qlNode = qlNode.prev\n      }\n      if (qlNode === dlNode.val.nil && dlNode.prev === this.dl.nil) {\n        dlNode = this.dl.insert()\n        qlNode = dlNode.val.nil\n      } else {\n        if (!qlNode.above) {\n          throw new Error('qlNode above must not be null')\n        }\n        qlNode = qlNode.above\n        dlNode = dlNode.prev\n      }\n      QuadList.insertAboveAfter(newqlNode, belowNode, qlNode)\n      belowNode = newqlNode\n    }\n  }\n  min() {\n    const tail = this.dl.nil.prev\n    return tail.val.nil.next.val\n  }\n  max() {\n    const tail = this.dl.nil.prev\n    return tail.val.nil.prev.val\n  }\n  remove(key: number) {\n    let { qlNode } = this._search(key)\n    if (this.mapValueKey(qlNode.val) === key) {\n      QuadList.remove(qlNode)\n      while (qlNode.above) {\n        qlNode = qlNode.above\n        QuadList.remove(qlNode)\n      }\n    }\n  }\n}\n","import { sortA, unique } from './array'\ninterface TreeNode {\n  l: number\n  r: number\n  v: any\n}\nabstract class SegmentTree<T> {\n  tree: TreeNode[]\n\n  constructor(\n    protected arr: T[],\n    protected getLeafValue: (v: any) => any,\n    protected getNotLeafValue: (vl: any, vr: any) => any\n  ) {\n    const n = arr.length\n    this.tree = Array(4 * n)\n    this._build(0, 0, n - 1)\n  }\n  protected _build(u: number, l: number, r: number) {\n    if (l === r) {\n      this.tree[u] = {\n        l,\n        r,\n        v: this.getLeafValue(this.arr[l]),\n      }\n      return\n    }\n    let m = Math.floor((l + r) / 2)\n    this._build(2 * u + 1, l, m)\n    this._build(2 * u + 2, m + 1, r)\n    this.tree[u] = {\n      l,\n      r,\n      v: this.getNotLeafValue(this.tree[2 * u + 1].v, this.tree[2 * u + 2].v),\n    }\n  }\n  protected _update(u: number, pos: number, v: T) {\n    const { l, r } = this.tree[u]\n    if (pos < l || pos > r) {\n      return\n    }\n    if (l === r) {\n      if (l === pos) {\n        this.tree[u].v = this.getLeafValue(v)\n      }\n      return\n    }\n    let m = Math.floor((l + r) / 2)\n    if (pos > m) {\n      this._update(2 * u + 2, pos, v)\n    } else {\n      this._update(2 * u + 1, pos, v)\n    }\n    this.tree[u].v = this.getNotLeafValue(\n      this.tree[2 * u + 1].v,\n      this.tree[2 * u + 2].v\n    )\n  }\n  abstract query(start: number, end: number): any\n  // abstract update(pos: number, value: T): void\n}\n\n/**\n * Max segment tree.\n * Query the maximum value of given range and update the value in O(Logn) time.\n *\n * @category segment tree\n * @example\n * ```js\n * const maxArr = new MaxArr([2,3,1,7,9])\n * const [l,r]=[0,2]\n * // find the maximum value from [l,r]\n * maxArr.query(l,r) //=> 3\n * maxArr.query(0,3) //=> 7\n * maxArr.update(1,9)\n * maxArr.query(0,3) //=> 9\n * ```\n * Provide the specified key\n * ```js\n * const maxArr = new MaxArr([{ name: 'li', age: 21 }, { name: 'wang', age: 24 }, { name: 'xx', age: 23 }],node=>node.age)\n * maxArr.query(0,2) //=> { name: 'wang', age: 24 }\n * maxArr.update(0, { name: 'xiao', age: 25 })\n * maxArr.query(0,2) //=> { name: 'xiao', age: 25 }\n * ```\n */\nexport class MaxArr<T> extends SegmentTree<T> {\n  mapValueKey: (node: T) => number\n  constructor(arr: T[], mapValueKey = (x: any) => x) {\n    super(\n      arr,\n      x => x,\n      (x, y) => {\n        return mapValueKey(x) - mapValueKey(y) >= 0 ? x : y\n      }\n    )\n    this.mapValueKey = mapValueKey\n  }\n  private _query(u: number, l: number, r: number): T | undefined {\n    const { l: _l, r: _r, v } = this.tree[u]\n    if (l <= _l && r >= _r) {\n      return v\n    }\n    if (r < _l || l > _r) {\n      return\n    }\n    let v1 = this._query(2 * u + 1, l, r)\n    let v2 = this._query(2 * u + 2, l, r)\n    if (v1 === undefined) {\n      return v2\n    } else if (v2 === undefined) {\n      return v1\n    }\n    return this.getNotLeafValue(v1, v2)\n  }\n  query(start = 0, end = this.arr.length - 1) {\n    return this._query(0, start, end)\n  }\n  update(pos: number, value: T) {\n    this.arr[pos] = value\n    this._update(0, pos, value)\n  }\n}\n\n/**\n * Sum segment tree.\n * Query the sum of given range and update the value in O(Logn) time.\n * @category segment tree\n * @example\n * ```js\n * const sumArr = new SumArr([2,3,1,7,9])\n * sumArr.query(0,2)\n * ```\n */\nexport class SumArr extends SegmentTree<number> {\n  constructor(arr: number[]) {\n    super(\n      arr,\n      x => x,\n      (x, y) => x + y\n    )\n  }\n  private _query(u: number, l: number, r: number): number {\n    const { l: _l, r: _r, v } = this.tree[u]\n    if (l <= _l && r >= _r) {\n      return v\n    }\n    if (r < _l || l > _r) {\n      return 0\n    }\n    let v1 = this._query(2 * u + 1, l, r)\n    let v2 = this._query(2 * u + 2, l, r)\n    return this.getNotLeafValue(v1, v2)\n  }\n  query(start = 0, end = this.arr.length - 1): number {\n    return this._query(0, start, end)\n  }\n  update(pos: number, value: number) {\n    this.arr[pos] = value\n    this._update(0, pos, value)\n  }\n}\n\n/**\n * Given an array contains all the values,\n * insert the value one by one,and\n *  query the number of value in [lower,upper].\n * @category segment tree\n * @example\n * ```js\n * const arr = [1, 2, 3, 5, 7]\n * const vArr = new ValueArr(arr)\n * vArr.insert(1)\n * vArr.insert(3)\n * vArr.insert(5)\n * assert.strictEqual(vArr.query(1, 3), 2)\n * assert.strictEqual(vArr.query(1, 5), 3)\n * vArr.insert(1)\n * assert.strictEqual(vArr.query(1, 5), 4)\n * ```\n */\nexport class ValueArr extends SegmentTree<number> {\n  constructor(arr: number[]) {\n    super(\n      sortA(unique(arr)),\n      () => 0,\n      (x, y) => x + y\n    )\n  }\n  private _query(u: number, low: number, upper: number): number {\n    const { l, r, v } = this.tree[u]\n    const lv = this.arr[l]\n    const rv = this.arr[r]\n    if (low <= lv && upper >= rv) {\n      return v\n    } else if (low > rv || upper < lv) {\n      return 0\n    }\n    return (\n      this._query(2 * u + 1, low, upper) + this._query(2 * u + 2, low, upper)\n    )\n  }\n  query(low: number, upper: number): number {\n    return this._query(0, low, upper)\n  }\n  private _insert(u: number, v: number) {\n    const node = this.tree[u]\n    const { l, r } = node\n    const lv = this.arr[l]\n    const rv = this.arr[r]\n    if (lv <= v && rv >= v) {\n      node.v++\n      if (l < r) {\n        this._insert(2 * u + 1, v)\n        this._insert(2 * u + 2, v)\n      }\n    }\n  }\n  insert(v: number) {\n    this._insert(0, v)\n  }\n}\n","/**\n * @category Union-find data structure\n * @example\n * ```js\n * const uf=new UnionFind(4);\n * uf.union(0, 1);\n * uf.union(1, 2);\n * uf.isSameSet(0, 2); //=> true\n * ```\n */\nexport class UnionFind {\n  size: number\n  fatherMap: number[]\n  sizeMap: number[]\n  /**\n   * @param n the  number of node\n   */\n  constructor(n: number) {\n    this.fatherMap = Array(n).fill(-1)\n    this.sizeMap = Array(n).fill(1)\n    this.size = n\n  }\n  /**\n   * find set representatives use `path compression`\n   * @param node\n   */\n  find(node: number): number {\n    if (this.fatherMap[node] === -1) {\n      return node\n    }\n    this.fatherMap[node] = this.find(this.fatherMap[node])\n    return this.fatherMap[node]\n  }\n  isSameSet(node1: number, node2: number): boolean {\n    const root1 = this.find(node1)\n    const root2 = this.find(node2)\n    return root1 === root2\n  }\n  /**\n   * merge two sets\n   * @param node1\n   * @param node2\n   */\n  union(node1: number, node2: number): void {\n    const root1 = this.find(node1)\n    const root2 = this.find(node2)\n    if (root1 === root2) {\n      return\n    }\n    if (this.sizeMap[root1] > this.sizeMap[root2]) {\n      this.fatherMap[root2] = root1\n      this.sizeMap[root2] = this.sizeMap[root2] + this.sizeMap[root1]\n    } else {\n      this.fatherMap[root1] = root2\n      this.sizeMap[root1] = this.sizeMap[root2] + this.sizeMap[root1]\n    }\n  }\n}\n","// the typescript implementation of Manacher's linear-time algorithm.\n// https://en.wikipedia.org/wiki/Longest_palindromic_substring\n// returns an array representing the longest palindrome substring centered around each location\n\nexport function getPalindromeArr(str: string) {\n  let len = str.length * 2 + 1\n\n  let s: string[] = Array(len).fill('|')\n  for (let i = 0; i < str.length; i++) {\n    s[2 * i + 1] = str[i]\n  }\n  let palindromeRadiusArr = Array(len).fill(0)\n  let center = 0\n  let radius = 0\n  while (center < len) {\n    while (\n      center - (radius + 1) >= 0 &&\n      center + (radius + 1) < len &&\n      s[center - radius - 1] === s[center + radius + 1]\n    ) {\n      radius++\n    }\n    palindromeRadiusArr[center] = radius\n    let oldCenter = center\n    let oldRadius = radius\n    center++\n    while (center <= oldCenter + oldRadius) {\n      let diff = oldCenter + oldRadius - center\n      if (palindromeRadiusArr[oldCenter * 2 - center] === diff) {\n        radius = diff\n        break\n      } else if (palindromeRadiusArr[oldCenter * 2 - center] > diff) {\n        palindromeRadiusArr[center] = oldCenter + oldRadius - center\n        center++\n      } else {\n        palindromeRadiusArr[center] =\n          palindromeRadiusArr[oldCenter * 2 - center]\n        center++\n      }\n    }\n  }\n  let originPalindromeRadiusArr = Array(str.length).fill(0)\n  for (let i = 0; i < originPalindromeRadiusArr.length; i++) {\n    originPalindromeRadiusArr[i] = palindromeRadiusArr[2 * i + 1]\n  }\n  return originPalindromeRadiusArr\n}\n","import { last } from './array'\nimport { TreeNode } from './treeNode'\n\n/**\n * The traversalFn will be executed in post-order\n * @param root\n * @param traversalFn\n * @category tree traversal\n * @mermaid\n *  flowchart TD\n *    B-->A\n *    B-->D\n *    D-->C\n * \t  D-->E\n * @example\n * ```js\n * postorder(root,(node,fatherNode)=>{console.log(node)})\n * // => A C E D B\n * ```\n */\nexport function postorder<T>(\n  root: TreeNode<T>,\n  fn1: (node: TreeNode<T>) => any\n) {\n  if (!root) {\n    return\n  }\n  let map = new Map()\n  let queue = [root]\n  while (queue.length) {\n    let top = last(queue)\n    if (!map.get(top)) {\n      map.set(top, true)\n      if (top.right) {\n        queue.push(top.right)\n      }\n      if (top.left) {\n        queue.push(top.left)\n      }\n    } else {\n      queue.pop()\n      fn1(top)\n    }\n  }\n}\n\n/**\n * The traversalFn will be executed in in-order\n * @param root\n * @param traversalFn\n * @category tree traversal\n * @mermaid\n *  flowchart TD\n *    B-->A\n *    B-->D\n *    D-->C\n * \t  D-->E\n * @example\n * ```js\n * inorder(root,(node,fatherNode)=>{console.log(node)})\n * // => A B C D E\n * ```\n */\nexport function inorder<T>(root: TreeNode<T>, fn1: (node: TreeNode<T>) => any) {\n  if (!root) {\n    return\n  }\n  let map = new Map()\n  let queue = [root]\n  while (queue.length) {\n    let top = last(queue)\n    if (!map.get(top)) {\n      map.set(top, true)\n      if (top.left) {\n        queue.push(top.left)\n      }\n    } else {\n      queue.pop()\n      fn1(top)\n      if (top.right) {\n        queue.push(top.right)\n      }\n    }\n  }\n}\n\n/**\n * The traversalFn will be executed in pre-order\n * @param root\n * @param traversalFn\n * @category tree traversal\n * @mermaid\n *  flowchart TD\n *    B-->A\n *    B-->D\n *    D-->C\n * \t  D-->E\n * @example\n * ```js\n * prevorder(root,(node,fatherNode)=>{console.log(node)})\n * // => B A D C E\n * ```\n */\nexport function prevorder<T>(\n  root: TreeNode<T>,\n  traversalFn: (node: TreeNode<T>, fatherNode: TreeNode<T> | null) => any\n) {\n  if (!root) {\n    return\n  }\n  let queue = [root]\n  let fatherMap = new Map()\n  fatherMap.set(root, null)\n  while (queue.length) {\n    let top = queue.pop() as TreeNode<T>\n    traversalFn(top, fatherMap.get(top))\n\n    if (top.right) {\n      fatherMap.set(top.right, top)\n      queue.push(top.right)\n    }\n    if (top.left) {\n      fatherMap.set(top.left, top)\n      queue.push(top.left)\n    }\n  }\n}\n"],"names":["TreeNode","constructor","val","left","right","serialize","root","JSON","stringify","arr","queue","length","node","shift","push","i","deserialize","originData","data","parse","leftVal","undefined","rightVal","outArr","join","ListNode","next","head","header","out","prev","cur","compare","v1","v2","Error","localeCompare","sortA","fn","x","fn2","sort","y","sortD","getCompareKey","getCompareKey2","key1","r","key3","last","max","arg","Array","isArray","Math","Infinity","num","unique","Set","isNil","value","hopcroftKarp","m","adjArr","map","Map","dist","bfs","has","dfs","shortDis","adjNodes","nextNode","get","adjNode","set","add","dfs2","index","isConnected","j","medium","lastValue","floor","ceil","random","min","c","n","bm","BigInt","bn","s","s2","RBSTNode","PQ","keys","mapValueKey","this","sink","insert","key","swim","exch","less","father","len","peek","poll","isEmpty","size","DoubleLinkNode","DoubleLink","qlList","QuadList","nil","firstLevel","ql","below","above","remove","QuadListNode","newNode","belowNode","leftNode","SegmentTree","getLeafValue","getNotLeafValue","tree","_build","u","l","v","_update","pos","_query","_l","_r","query","start","end","update","delMax","delMin","insertAsRoot","item","split","leftTree","rightTree","total","_insert","search","curKey","p","newTree","findKMax","k","prevNum","curRank","dl","_search","dlNode","qlNode","tail","newqlNode","insertAboveAfter","fatherMap","fill","sizeMap","find","isSameSet","node1","node2","union","root1","root2","low","upper","lv","rv","d","Number","result","t","gcd","a","b","adjMatrix","str","palindromeRadiusArr","center","radius","oldCenter","oldRadius","diff","originPalindromeRadiusArr","initArray","dimension","isInteger","from","slice","fn1","top","pop","arr1","arr2","e","intervals","interval","edge","splice","forEach","adjVertices","newX","coverVertices","remainder","reverse","traversalFn","x0","y0","reduce","indexArr"],"mappings":"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"}