'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }

}
/**
 * Encodes a tree to a single string.
 *
 * @mermaid
 * graph LR
 *   1 --- 2
 *   1 --- 3
 *   3 --- 4
 *   3 --- 5
 * @example
 * ```js
 * serialize(root) // => '[1,2,3,null,null,4,5]'
 * ```
 */

function serialize(root) {
  if (!root) {
    return JSON.stringify([]);
  }

  let arr = [];
  let queue = [root];

  while (queue.length) {
    let node = queue.shift();

    if (node) {
      arr.push(node.val);
      queue.push(node.left);
      queue.push(node.right);
    } else {
      arr.push(null);
    }
  }

  let i = arr.length - 1;

  while (arr[i] === null) {
    i--;
  }

  arr.length = i + 1;
  return JSON.stringify(arr);
}

function serializeArr(arr) {
  const outArr = [];

  for (let i = 0; i < arr.length; i++) {
    outArr.push(serialize(arr[i]));
  }

  return '[' + outArr.join(',') + ']';
}
/**
 * Decodes your encoded data to tree.
 */


function deserialize(originData) {
  const data = JSON.parse(originData);

  if (!data.length) {
    return null;
  }

  let val = data.shift();
  let root = new TreeNode(val);
  let queue = [root];

  while (queue.length) {
    let node = queue.shift();
    let leftVal = data.shift();

    if (leftVal === undefined) {
      return root;
    }

    if (leftVal !== null) {
      let left = new TreeNode(leftVal);
      node.left = left;
      queue.push(left);
    }

    let rightVal = data.shift();

    if (rightVal === undefined) {
      return root;
    }

    if (rightVal !== null) {
      let right = new TreeNode(rightVal);
      node.right = right;
      queue.push(right);
    }
  }

  return root;
}

function deserializeArr(originData) {
  const data = JSON.parse(originData);

  if (!data.length) {
    return [];
  }

  let outArr = [];

  for (let i = 0; i < data.length; i++) {
    outArr.push(deserialize(JSON.stringify(data[i])));
  }

  return outArr;
}
/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */

var treeNode = {
  __proto__: null,
  TreeNode: TreeNode,
  serialize: serialize,
  deserialize: deserialize,
  serializeArr: serializeArr,
  deserializeArr: deserializeArr
};

class ListNode {
  constructor(val = undefined, next = null) {
    this.val = val;
    this.next = next;
  }

}
/**
 * Encodes a list to a single string.
 *
 * @mermaid
 * graph LR
 *   1 --- 2
 *   2 --- 3
 *   3 --- 4
 *   4 --- 5
 * @example
 * ```js
 * serialize(root) // => '[1,2,3,4,5]'
 * ```
 */

function serialize$1(head) {
  if (!head) {
    return JSON.stringify([]);
  }

  let arr = [];
  let node = head;

  while (node) {
    arr.push(node.val);
    node = node.next;
  }

  return JSON.stringify(arr);
}
function serializeArr$1(arr) {
  let out = [];

  for (let i = 0; i < arr.length; i++) {
    out.push(serialize$1(arr[i]));
  }

  return '[' + out.join(',') + ']';
}
/**
 * Decodes your encoded data to list.
 */

function deserialize$1(originData) {
  const data = JSON.parse(originData);
  let header = new ListNode();
  let node = header;

  for (let i = 0; i < data.length; i++) {
    node.next = new ListNode(data[i]);
    node = node.next;
  }

  return header.next;
}
function deserializeArr$1(originData) {
  const arr = JSON.parse(originData);
  let out = [];

  for (let i = 0; i < arr.length; i++) {
    out.push(deserialize$1(JSON.stringify(arr[i])));
  }

  return out;
}
/**
 * reverse a list
 */

function reverseList(head) {
  if (!head) {
    return null;
  }

  let prev = null;
  let cur = head;

  while (cur) {
    let next = cur.next;
    cur.next = prev;
    prev = cur;
    cur = next;
  }

  return prev;
}

var listNode = {
  __proto__: null,
  ListNode: ListNode,
  serialize: serialize$1,
  serializeArr: serializeArr$1,
  deserialize: deserialize$1,
  deserializeArr: deserializeArr$1,
  reverseList: reverseList
};

/**
 * Initializes an array with initial value of 0
 * @return return the new array
 * @category array
 * @example
 * ```js
 * initArray(3) // => [0,0,0]
 * initArray([3,2]) // => [[0,0],[0,0],[0,0]]
 * ```
 */
function initArray(dimension) {
  if (Number.isInteger(dimension)) {
    return Array(dimension).fill(0);
  }

  if (!Array.isArray(dimension)) {
    throw new Error('dimension sould be int or int array');
  }

  if (dimension.length === 1) {
    let len = dimension[0];
    return Array(len).fill(0);
  }

  let len = dimension[0];
  return Array.from(Array(len), () => [...initArray(dimension.slice(1))]);
}
/**
 * Initializes a two-dimensional array
 * @param m
 * @param n
 * @param value the default value of element
 * @category array
 * @return return the new array
 * @example
 * ```js
 * init2Array(2,3) // => [[0,0,0],[0,0,0]]
 * ```
 */

function init2Array(m, n, value = 0) {
  const arr = [];

  for (let i = 0; i < m; i++) {
    arr[i] = Array(n).fill(value);
  }

  return arr;
}
/**
 * merge all overlapped intervals
 * @param intervals
 * @category array
 * @example
 * ```js
 * mergeArray([[0,1],[1,2],[3,4]]) // => [[0,2],[3,4]]
 * ```
 */

function mergeArray(intervals) {
  if (!intervals.length) {
    return [];
  }

  intervals.sort((arr1, arr2) => arr1[0] - arr2[0]);
  let prev = intervals[0];
  let result = [];

  for (let i = 1; i < intervals.length; i++) {
    if (intervals[i][0] <= prev[1]) {
      prev = [prev[0], Math.max(intervals[i][1], prev[1])];
    } else {
      result.push(prev);
      prev = intervals[i];
    }
  }

  result.push(prev);
  return result;
}
/**
 * Intersection of two array
 * @param {any[]} arr1
 * @param {any[]} arr2
 * @return {any[]}
 * @category array
 * @example
 * ```js
 * intersect([1,2],[2,3]) // => [2]
 * ```
 */

function intersect(arr1, arr2) {
  const set = new Set(arr1);
  let result = [];

  for (let i = 0; i < arr2.length; i++) {
    const e = arr2[i];

    if (set.has(e)) {
      result.push(e);
    }
  }

  return result;
}
/**
 *  the min sum to make array unique by subtracting of the element
 * @param arr an array of int
 * @category array
 * @example
 * ```js
 * countOfUniqueD([3,3,1]) // => 1,the unique array should be [3,2,1], 3->2
 * countOfUniqueD([3,3,3]) // => 3,the unique array should be [3,2,1], 3->2, 3->1
 * ```
 */

function countOfUniqueD(arr) {
  let result = 0;

  if (arr.length <= 1) {
    return 0;
  }

  sortD(arr);
  let t = arr[0];

  for (let i = 1; i < arr.length; i++) {
    t--;

    if (t > arr[i]) {
      t = arr[i];
    } else {
      result += arr[i] - t;
    }
  }

  return result;
}
/**
 * the min sum to make array unique by increasing the element
 * @param arr an array of int
 * @category array
 * @example
 * ```js
 * countOfUniqueA([1,1,2]) // => 2,the unique array should be [1,2,3]
 * countOfUniqueA([0,2,2,2,3]) // => 5 ,the unique array should be [0,2,3,4,5], 2->4,2->5
 * ```
 */

function countOfUniqueA(arr) {
  let result = 0;

  if (arr.length <= 1) {
    return 0;
  }

  sortA(arr);
  let t = arr[0];

  for (let i = 1; i < arr.length; i++) {
    t++;

    if (t < arr[i]) {
      t = arr[i];
    } else {
      result += t - arr[i];
    }
  }

  return result;
}
/**
 * reverse the array from start to end
 * @category array
 * @example
 * ```js
 * reverse([2,3,4]) // => [4,3,2]
 * ```
 */

function reverse(arr, start = 0, end = arr.length - 1) {
  for (let i = start; i < (start + end) / 2; i++) {
    let t = arr[i];
    arr[i] = arr[start + end - i];
    arr[start + end - i] = t;
  }

  return arr;
}
/**
 * return an index arr
 * @category array
 * @example
 * ```js
 * toIndexArr([1,2,3]) // => [{index:0,value:1},{index:1,value:2},{index:2,value:3}]
 * ```
 */

function toIndexArr(arr) {
  let indexArr = [];

  for (let i = 0; i < arr.length; i++) {
    indexArr[i] = {
      index: i,
      value: arr[i]
    };
  }

  return indexArr;
}

function compare(v1, v2) {
  if (typeof v1 !== typeof v2) {
    throw new Error('the type of key should be the same');
  }

  if (typeof v1 !== 'string') {
    return v1 - v2;
  } else {
    return v1.localeCompare(v2);
  }
}
/**
 * Sort the array in ascending order by key
 * @param  arr the array
 * @param  fn return the key to sort, default key is value
 * @param  fn2 if the key is equal, using the second key
 * @category array
 * @example
 * ```js
 * sortA([3,1,2]) // => [1,2,3]
 * sortA([{height:3},{height:2},{height:1}],x=>x.height) // => [{height:1},{height:2},{height:3}]
 * sortA(['ca','ba','bd']) // => ['ba','bd','ca']
 * ```
 */


function sortA(arr, fn = x => x, fn2 = fn) {
  return arr.sort((x, y) => {
    const key1 = fn(x);
    const key2 = fn(y);
    const r = compare(key1, key2);

    if (r) {
      return r;
    }

    const key3 = fn2(x);
    const key4 = fn2(y);
    return compare(key3, key4);
  });
}
/**
 * Sort the array in descending order by key
 * will change the origin array
 * @param  arr the array
 * @param  getCompareKey return the key to sort
 * @param  getCompareKey2 if the key is equal, using the second key
 * @category array
 * @example
 * ```js
 * sortD([3,1,2]) // => [3,2,1]
 * sortD([{height:3},{height:2},{height:1}],x=>x.height) // => [{height:3},{height:2},{height:1}]
 * sortD(['ca','ba','bd']) // => ['ca','bd','ba']
 * sortD([{value:1,index:1},{value:2,index:3},{value:2,index:2}],x=>x.value,x=>x.index)
 * // => [{value:2,index:3},{value:2,index:2},{value:1,index:1}]
 * ```
 */

function sortD(arr, getCompareKey = x => x, getCompareKey2 = getCompareKey) {
  return arr.sort((x, y) => {
    const key1 = getCompareKey(x);
    const key2 = getCompareKey(y);
    const r = compare(key2, key1);

    if (r) {
      return r;
    }

    const key3 = getCompareKey2(x);
    const key4 = getCompareKey2(y);
    return compare(key4, key3);
  });
}
/**
 * Return the last value
 * @param arr the array
 * @category array
 * ```js
 * last([2,1,5]) // => 5
 * last([]) // => undefined
 * ```
 */

function last(arr) {
  return arr[arr.length - 1];
}
/**
 * compute the sum of an array
 * @category array
 * @example
 * ```js
 * sum([1,2,3]) // => 6
 * sum([]) // => 0
 * ```
 */

function sum(arr) {
  return arr.reduce((prev, cur) => prev + cur, 0);
}
/**
 * Get the max value
 * @category array
 * @example
 * ```js
 * max(1,3,2) // => 3
 * max([1,3,2]) // => 3
 * ```
 */

function max(...arg) {
  if (!Array.isArray(arg[0])) {
    return Math.max(...arg);
  }

  arg = arg[0];

  if (arg.length <= 10000) {
    return Math.max(...arg);
  }

  let max = -Infinity;

  for (const num of arg) {
    max = Math.max(max, num);
  }

  return max;
}
/**
 * Get the min value
 * @category array
 * @example
 * ```js
 * min(1,3,2) // => 1
 * min([1,3,2]) // => 1
 * ```
 */

function min(...arg) {
  if (!Array.isArray(arg[0])) {
    return Math.min(...arg);
  }

  arg = arg[0];

  if (arg.length <= 10000) {
    return Math.min(...arg);
  }

  let min = Infinity;

  for (const num of arg) {
    min = Math.min(min, num);
  }

  return min;
}
/**
 * return a new arr that does not contains duplicate elements.
 * @category array
 * @example
 * ```js
 * unique([1,1,2,2,2,6,1]) //=> [1,2,6]
 * ```
 */

function unique(arr) {
  return [...new Set(arr)];
}

/**
 * check if the value is `undefined`
 */
function isNil(value) {
  return value === undefined;
}
/**
 * bipartite matching algorithms
 *
 * the [Hopcroft–Karp algorithm](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) is an algorithm that takes as input a bipartite graph and produces as output a maximum cardinality matching
 *
 * bipartite graph contains two vertex set X and Y
 * @param m the number of X
 * @param adj the adjacency array of X
 * @category Graph
 * @example
 * ```js
 * hopcroftKarp(5,[[5, 6], [5, 9], [7, 8], [5, 9], [6, 8]])
 * // => Map(10){ 0=>6,1=>9,2=>7,3=>5,4=>8,6=>0,7=>2,8=>4,9=>1 }
 * ```
 */


function hopcroftKarp(m, adjArr) {
  // record the matching vertices
  let map = new Map();
  let dist = {};

  while (bfs(map, dist, m, adjArr)) {
    // dfs stage
    for (let i = 0; i < m; i++) {
      // the augmenting-path start from a unmatched vertice
      if (!map.has(i)) {
        dfs(i, map, dist, m, adjArr);
      }
    }
  }

  return map;
}
/**
 * compute the shortest distance of all the vertices in X
 * @param map record the matching vertices
 * @param dist the distance map of the vertices in X
 * @param m the number of X
 * @param adjArr the adjacency array of X
 */

function bfs(map, dist, m, adjArr) {
  let queue = []; // record the shortest length of augmenting-path
  // in fact the shortest length is shortDis*2-1

  let shortDis = Infinity; // init the distance of vertices in every bfs stage
  // the distance is 0 when the vertice do not match, or that is Infinity

  for (let i = 0; i < m; i++) {
    if (!map.has(i)) {
      dist[i] = 0;
      queue.push(i);
    } else {
      dist[i] = Infinity;
    }
  }

  while (queue.length) {
    const node = queue.shift(); // this ensure all the augmenting-path length in the next dfs stage equal shortDis

    if (dist[node] >= shortDis) {
      break;
    }

    const adjNodes = adjArr[node];

    for (let i = 0; i < adjNodes.length; i++) {
      const adjNode = adjNodes[i];
      const nextNode = map.get(adjNode);

      if (isNil(nextNode)) {
        // find a augmenting-path
        shortDis = dist[node] + 1;
      } else if (dist[nextNode] === Infinity) {
        dist[nextNode] = dist[node] + 1;
        queue.push(nextNode);
      }
    }
  }

  return shortDis < Infinity;
}

function dfs(node, map, dist, m, adjArr) {
  const adjNodes = adjArr[node];

  for (let i = 0; i < adjNodes.length; i++) {
    const adjNode = adjNodes[i];
    const nextNode = map.get(adjNode); //find a augmenting-path

    if (isNil(nextNode)) {
      map.set(node, adjNode);
      map.set(adjNode, node);
      return true;
    } else if (dist[nextNode] === dist[node] + 1) {
      if (dfs(nextNode, map, dist, m, adjArr)) {
        map.set(node, adjNode);
        map.set(adjNode, node);
        return true;
      }
    }
  } // mark this vertice has fail,so is will not visit in current dfs stage


  dist[node] = Infinity;
  return false;
}

/**
 * Calculate the connectivity degree according to the undirected graph adjacency array.
 * @param {number[][]} adjArr adjacency array
 * @param {number} n vertex number
 * @category Graph
 * @mermaid
 * graph LR
 *   0 --- 4
 *   1 --- 2
 *   2 --- 3
 * @example
 * ```js
 * getConnectedNumByAdjArr([[4],[2],[1,3],[2],[0]]) // => 2
 * ```
 */

function getConnectedNumByAdjArr(adjArr, n = adjArr.length) {
  let set = new Set();
  let num = 0;

  for (let i = 0; i < n; i++) {
    if (!set.has(i)) {
      num++;
      dfs$1(i, set, adjArr);
    }
  }

  return num;
}

function dfs$1(node, set, adjArr) {
  set.add(node);
  const adjNodes = adjArr[node] || [];

  for (let i = 0; i < adjNodes.length; i++) {
    if (!set.has(adjNodes[i])) {
      dfs$1(adjNodes[i], set, adjArr);
    }
  }
}
/**
 * Calculate the connectivity degree according to the undirected graph adjacency matrix.
 * @category Graph
 * @param {number[][]} adjMatrix 邻接矩阵
 */


function getConnectedNumByAdjMatrix(adjMatrix) {
  let num = 0;
  const n = adjMatrix.length;
  let set = new Set();

  for (let i = 0; i < n; i++) {
    if (!set.has(i)) {
      num++;
      dfs2(i, set, adjMatrix);
    }
  }

  return num;
}

function dfs2(index, set, isConnected) {
  set.add(index);

  for (let j = 0; j < isConnected.length; j++) {
    if (isConnected[index][j] && !set.has(j)) {
      dfs$1(j, set, isConnected);
    }
  }
}
/**
 * bipartite graph contains two vertex set X and Y
 * Reference:https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)
 * @param m the number of set X
 * @param adjArr the adjacency array of X
 * @param n the number of set Y
 */


function minCoverVertices(m, adjArr, n) {
  const map = hopcroftKarp(m, adjArr);

  if (n === undefined) {
    n = max(adjArr.map(edge => max(edge))) + 1;
  }

  let arr = [];
  let set = new Set();

  for (let i = 0; i < m; i++) {
    // find not matched vertex in m
    if (!map.has(i)) {
      set.add(i);
      arr.push(i);
    }
  }

  while (arr.length) {
    {
      const copyArr = arr.splice(0);
      copyArr.forEach(x => {
        let adjVertices = adjArr[x];

        for (let i = 0; i < adjVertices.length; i++) {
          let y = adjVertices[i];

          if (!set.has(y)) {
            set.add(y);
            const newX = map.get(y);
            arr.push(newX);
            set.add(newX);
          }
        }
      });
    }
  }

  let coverVertices = [];

  for (let i = 0; i < m; i++) {
    if (!set.has(i)) {
      coverVertices.push(i);
    }
  }

  for (let i = m; i < n; i++) {
    if (set.has(i)) {
      coverVertices.push(i);
    }
  }

  return coverVertices;
}

/**
 * minimum number of intervals to cover the target interval
 * @category interval
 */

function minIntervalCover(intervals) {
  sortA(intervals, v => v[0]);

  if (!intervals.length) {
    return 0;
  }

  let c = 1;
  let [, right] = intervals[0];

  for (let i = 1; i < intervals.length; i++) {
    if (intervals[i][0] <= right) {
      right = Math.max(right, intervals[i][1]);
    } else {
      c++;
      right = intervals[i][1];
    }
  }

  return c;
}
/**
 *
 * @param {number[][]} intervals
 * @category interval
 */

function maxIntervalDisjoint(intervals) {
  sortA(intervals, v => v[1]);

  if (!intervals.length) {
    return 0;
  }

  let c = 1;
  let [, right] = intervals[0];

  for (let i = 1; i < intervals.length; i++) {
    const interval = intervals[i];

    if (interval[0] > right) {
      c++;
      right = interval[1];
    }
  }

  return c;
}
/**
 * @category interval
 */

const medium = /*#__PURE__*/function () {
  let lastValue = null;
  return function (left, right) {
    let m = Math.floor((left + right) / 2);

    if (m === lastValue) {
      m = Math.ceil((left + right) / 2);
    }

    lastValue = m;
    return m;
  };
}();

/**
 * Randomly returns integers in [min, max)
 * @category math
 * @example
 * ```js
 * random(1,2) // => 1
 * random(2,8) // => 4
 * ```
 */
function random(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(min + Math.random() * (max - min));
}
/**
 * Next bigger permutation
 * @param arr
 * @category math
 * @example
 * ```js
 * nextPermutation([1,2,3,4]) // => [1,2,4,3]
 * nextPermutation([4,3,2,1]) // => [1,2,3,4]
 * ```
 */

function nextPermutation(arr) {
  let i = arr.length - 1;

  while (i >= 1 && arr[i] <= arr[i - 1]) {
    i--;
  }

  if (i === 0) {
    return arr.reverse();
  }

  i--;
  let min = arr[i + 1];
  let index = i + 1;

  for (let j = arr.length - 1; j > i; j--) {
    if (arr[j] > arr[i] && arr[j] < min) {
      min = Math.min(arr[j], min);
      index = j;
    }
  }
  [arr[i], arr[index]] = [arr[index], arr[i]];

  for (let j = i + 1; j <= Math.floor((i + arr.length) / 2); j++) {
    [arr[j], arr[arr.length + i - j]] = [arr[arr.length + i - j], arr[j]];
  }

  return arr;
}
/**
 * Get the greatest common divisor of a and b
 * @category math
 * @example
 * ```js
 * gcd(4,2) // => 2
 * gcd(9,6) // => 3
 * ```
 */

function gcd(a, b) {
  if (b === 0) {
    return a;
  }

  return gcd(b, a % b);
}
/**
 * The coordinates of the point [x,y] are rotated 90° anticlockwise around [x0,y0]
 * @category math
 * @example
 * ```js
 * rotate90([1,1],[2,2]) // => [1,3]
 * ```
 */

function rotate90([x, y], [x0, y0]) {
  return [x0 + y0 - y, x - x0 + y0];
}
/**
 * The coordinate of the point [x,y] are rotated 90° clockwise around [x0,y0]
 * @category math
 */

function rotateCw90([x, y], [x0, y0]) {
  return [y - y0 + x0, x0 - x + y0];
}
/**
 * Compute the number of permutations c(n,m)=n*(n-1)*...(n-m+1)/(m!)
 * @category math
 * @example
 * ```js
 * c(5,2) // => 10n
 * c(4,2) // => 6n
 * c(5,0) // => 1n
 * ```
 */

function c(n, m) {
  if (m === 0) {
    return 1n;
  }

  const bm = BigInt(m);
  const bn = BigInt(n);
  let s = 1n;
  let s2 = 1n;

  for (let i = 0n; i < bm; i++) {
    s *= bn - i;
  }

  for (let i = 1n; i <= bm; i++) {
    s2 *= i;
  }

  return s / s2;
}
/**
 * First compute the number of permutations c(n,m)=n*(n-1)*...(n-m+1)/(m!)
 * Then take the remainder of modulo 10 * * 9 + 7
 * @category math
 * @example
 * ```js
 * cm(5,2) // => 10
 * cm(4,2) // => 6
 * cm(5,0) // => 1
 * ```
 */

function cm(n, m) {
  const d = BigInt(10 ** 9 + 7);
  return Number(c(n, m) % d);
}
/**
 * Returns the i th bit of the absolute value of num
 * @example
 * ```js
 * bit(9,1) // => 0
 * bit(4,2) // => 1
 * bit(3,0) // => 1
 * ```
 */

function bit(num, i) {
  if (num < 0) num = num * -1;

  while (i > 0) {
    num = Math.floor(num / 2);
    i--;
  }

  return num % 2;
}
/**
 * Get the number of 1 in the binary number
 * @param n the number
 * @example
 * ```js
 * bitCount(0) // => 0
 * bitCount(3) // => 2
 * bitCount(4) // => 1
 * ```
 */

function bitCount(n) {
  let c = 0;

  while (n) {
    if (n % 2 === 1) {
      c++;
    }

    n = Math.floor(n / 2);
  }

  return c;
}
/**
 * Compute the remainder of m mod n.
 * The remainder is greater than or equal to 0.
 * @param m
 * @param n
 * @example
 * ```js
 * mod(2,3) // => 2
 * mod(-2,3) // => 1
 * mod(3,2) // => 1
 * mod(-2,2) // => 0
 * ```
 */

function mod(m, n) {
  const remainder = m % n;

  if (remainder < 0) {
    return remainder + n;
  }

  return remainder;
}

/**
 * The traversalFn will be executed in post-order
 * @param root
 * @param traversalFn
 * @category tree traversal
 * @mermaid
 *  flowchart TD
 *    B-->A
 *    B-->D
 *    D-->C
 * 	  D-->E
 * @example
 * ```js
 * postorder(root,(node,fatherNode)=>{console.log(node)})
 * // => A C E D B
 * ```
 */

function postorder(root, fn1) {
  if (!root) {
    return;
  }

  let map = new Map();
  let queue = [root];

  while (queue.length) {
    let top = last(queue);

    if (!map.get(top)) {
      map.set(top, true);

      if (top.right) {
        queue.push(top.right);
      }

      if (top.left) {
        queue.push(top.left);
      }
    } else {
      queue.pop();
      fn1(top);
    }
  }
}
/**
 * The traversalFn will be executed in in-order
 * @param root
 * @param traversalFn
 * @category tree traversal
 * @mermaid
 *  flowchart TD
 *    B-->A
 *    B-->D
 *    D-->C
 * 	  D-->E
 * @example
 * ```js
 * inorder(root,(node,fatherNode)=>{console.log(node)})
 * // => A B C D E
 * ```
 */

function inorder(root, fn1) {
  if (!root) {
    return;
  }

  let map = new Map();
  let queue = [root];

  while (queue.length) {
    let top = last(queue);

    if (!map.get(top)) {
      map.set(top, true);

      if (top.left) {
        queue.push(top.left);
      }
    } else {
      queue.pop();
      fn1(top);

      if (top.right) {
        queue.push(top.right);
      }
    }
  }
}
/**
 * The traversalFn will be executed in pre-order
 * @param root
 * @param traversalFn
 * @category tree traversal
 * @mermaid
 *  flowchart TD
 *    B-->A
 *    B-->D
 *    D-->C
 * 	  D-->E
 * @example
 * ```js
 * prevorder(root,(node,fatherNode)=>{console.log(node)})
 * // => B A D C E
 * ```
 */

function prevorder(root, traversalFn) {
  if (!root) {
    return;
  }

  let queue = [root];
  let fatherMap = new Map();
  fatherMap.set(root, null);

  while (queue.length) {
    let top = queue.pop();
    traversalFn(top, fatherMap.get(top));

    if (top.right) {
      fatherMap.set(top.right, top);
      queue.push(top.right);
    }

    if (top.left) {
      fatherMap.set(top.left, top);
      queue.push(top.left);
    }
  }
}

class RBSTNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
    this.size = 1;
  }

}
/**
 * @category randomized binary search tree.
 * @description
 * a randomized binary search tree.
 * `search`, `insert`, `remove`, `find the k-th max value` achieve O(Logn) expected performance.
 * @example
 * ```js
 * const rbst = new RBST()
 * const arr=[1,7,3]
 * arr.forEach(v=>{
 *  rbst.insert(v)
 * })
 * rbst.search(3) // => 3
 * rbst.findKMax(1) // => 7
 * rbst.remove(3)
 * rbst.findKMax(2) // => 1
 *
 * ```
 */


class RBST {
  constructor(fn = x => x) {
    this.root = null;
    this.mapValueKey = fn;
  }
  /**
   * Insert the item as the root of the tree.
   * @param item
   * @param tree
   */


  insertAsRoot(item, tree) {
    if (!tree) {
      return new RBSTNode(item);
    }

    const size = tree.size + 1;
    const key = this.mapValueKey(item);
    const [left, right] = this.split(key, tree);
    const newNode = new RBSTNode(item, left, right);
    newNode.size = size;
    return newNode;
  }
  /**
   * Divide the tree into two parts :leftTree and rightTree.
   * The leftTree key is less than the specified key,
   * and the rightTree key is greater than the specified key.
   * @param key
   * @param tree
   */


  split(key, tree) {
    if (!tree) {
      return [null, null];
    }

    if (this.mapValueKey(tree.val) > key) {
      let [leftTree, rightTree] = this.split(key, tree.left);
      tree.left = rightTree;
      tree.size -= leftTree ? leftTree.size : 0;
      return [leftTree, tree];
    } else {
      let [leftTree, rightTree] = this.split(key, tree.right);
      tree.right = leftTree;
      tree.size -= rightTree ? rightTree.size : 0;
      return [tree, rightTree];
    }
  }
  /**
   * merge the leftTree and rightTree into one tree.
   * @param leftTree
   * @param rightTree
   */


  join(leftTree, rightTree) {
    const m = leftTree ? leftTree.size : 0;
    const n = rightTree ? rightTree.size : 0;
    const total = m + n;
    if (!total) return null;
    const r = random(0, n + m);

    if (r < m) {
      leftTree.right = this.join(leftTree.right, rightTree);
      leftTree.size = total;
      return leftTree;
    } else {
      rightTree.left = this.join(leftTree, rightTree.left);
      rightTree.size = total;
      return rightTree;
    }
  }

  _insert(item, tree) {
    if (!tree) {
      return this.insertAsRoot(item, tree);
    }

    const n = tree.size;
    const r = random(0, n + 1);

    if (r === n) {
      return this.insertAsRoot(item, tree);
    } else if (this.mapValueKey(item) < this.mapValueKey(tree.val)) {
      tree.left = this._insert(item, tree.left);
    } else {
      tree.right = this._insert(item, tree.right);
    }

    tree.size++;
    return tree;
  }

  insert(item) {
    this.root = this._insert(item, this.root);
  }

  search(key) {
    let tree = this.root;

    while (tree) {
      const curKey = this.mapValueKey(tree.val);

      if (key === curKey) {
        return tree.val;
      } else if (key < curKey) {
        tree = tree.left;
      } else {
        tree = tree.right;
      }
    }

    return null;
  }

  remove(key) {
    if (this.search(key) === null) {
      return;
    }

    let tree = this.root;
    let father = null;
    let p;

    while (tree) {
      const curKey = this.mapValueKey(tree.val);

      if (key === curKey) {
        if (!father) {
          this.root = this.join(tree.left, tree.right);
        } else {
          const newTree = this.join(tree.left, tree.right);
          father[p] = newTree;
        }

        return;
      } else if (key < curKey) {
        father = tree;
        p = 'left';
        tree.size--;
        tree = tree.left;
      } else {
        father = tree;
        p = 'right';
        tree.size--;
        tree = tree.right;
      }
    }

    return null;
  }
  /**
   * find the k-th max item
   * @param k
   */


  findKMax(k) {
    const root = this.root;
    if (!root) return null;
    const size = root.size;
    k = size + 1 - k;

    if (k > size) {
      return null;
    }

    let tree = root;
    let prevNum = 0;

    while (tree) {
      var _tree$left;

      const leftSize = ((_tree$left = tree.left) == null ? void 0 : _tree$left.size) || 0;
      const curRank = prevNum + leftSize + 1;

      if (k === curRank) {
        return tree.val;
      } else if (k < curRank) {
        tree = tree.left;
      } else {
        prevNum = curRank;
        tree = tree.right;
      }
    }

    return null;
  }

}

class PQ {
  constructor(keys = [], fn = x => x) {
    this.keys = [...keys];
    this.mapValueKey = fn;

    for (let i = Math.floor((this.keys.length - 2) / 2); i >= 0; i--) {
      this.sink(i);
    }
  }

  insert(key) {
    this.keys.push(key);
    this.swim(this.keys.length - 1);
  }

  exch(i, j) {
    [this.keys[i], this.keys[j]] = [this.keys[j], this.keys[i]];
  }

  less(i, j) {
    return this.mapValueKey(this.keys[i]) - this.mapValueKey(this.keys[j]) < 0;
  }

  swim(index) {
    let father = Math.floor((index - 1) / 2);

    while (father >= 0 && this.less(father, index)) {
      this.exch(index, father);
      index = father;
      father = Math.floor((father - 1) / 2);
    }
  }

  sink(index) {
    let len = this.keys.length;
    let j = index * 2 + 1;

    while (j < len) {
      if (j + 1 < len && this.less(j, j + 1)) {
        j++;
      }

      if (this.less(index, j)) {
        this.exch(index, j);
        index = j;
        j = j * 2 + 1;
      } else {
        break;
      }
    }
  }

  peek() {
    return this.keys[0];
  }

  poll() {
    let head = this.peek();
    this.exch(0, this.keys.length - 1);
    this.keys.length = this.keys.length - 1;
    this.sink(0);
    return head;
  }

  isEmpty() {
    return !this.keys.length;
  }

  size() {
    return this.keys.length;
  }

}
/**
 * @category priority queue
 * @example
 * ```js
 * const input =  [4, 3, 1]
 * const maxP = new MaxPQ(input)
 * maxP.max() //=> 4
 * maxP.insert(5)
 * maxP.max() //=> 5
 * maxP.insert(8)
 * maxP.max() //=> 8
 * maxP.delMax()
 * maxP.max() //=> 5
 * ```
 * Provide the specified key
 * ```js
 * const input = [{ name: 'xiao', age: 21 }, { name: 'wang', age: 22 }, { name: 'li', age: 25 }]
 * const maxP = new MaxPQ(input, v => v.age)
 * const m = maxP.max() //=> { name: 'li', age: 25 }
 * ```
 *
 */


class MaxPQ extends PQ {
  max() {
    return this.peek();
  }

  delMax() {
    return this.poll();
  }

}
/**
 * @category priority queue
 * @example
 * ```js
 * const minPQ = new MinPQ([5, 1, 4, 2])
 * minPQ.min() // => 1
 * minPQ.delMin()
 * minPQ.min() // => 2
 * ```
 * Provide the specified key
 * ```js
 * const input = [{ name: 'xiao', age: 21 }, { name: 'wang', age: 22 }, { name: 'li', age: 25 }]
 * const minP = new MinPQ(input, v => v.age)
 * minP.min() // => { name: 'xiao', age: 21 }
 * ```
 */

class MinPQ extends PQ {
  constructor(keys = [], fn = x => x) {
    super(keys, x => -1 * fn(x));
  }

  min() {
    return this.peek();
  }

  delMin() {
    return this.poll();
  }

}

/**
 *   SkipList structure
 *   ---------------
 *  |     head(nil) |
 *  |       |       |
 *  |DoubleListNode | -> head(nil) - QuadListNode - QuadListNode - tail(nil)
 *  |       |       |      |                        |
 *  |DoubleListNode | -> head(nil) - QuadListNode - QuadListNode - tail(nil)
 *  |       |       |
 *  |     tail(nil) |
 *   ---------------
 *          ^
 *          |
 *          |
 *      DoubleList
 *
 *
 */
class DoubleLinkNode {
  constructor(val) {
    this.next = this;
    this.prev = this;
    this.val = val;
  }

}
class DoubleLink {
  constructor() {
    const qlList = new QuadList();
    this.nil = new DoubleLinkNode(qlList);
  }

  firstLevel() {
    if (this.nil.next === this.nil) {
      this.insert();
    }

    return this.nil.next;
  }

  insert() {
    const ql = new QuadList();
    const node = new DoubleLinkNode(ql);
    this.nil.next.prev = node;
    node.next = this.nil.next;
    this.nil.next = node;
    node.prev = this.nil;

    if (node.next !== this.nil) {
      // link the above node and below node
      node.val.nil.below = node.next.val.nil;
      node.next.val.nil.above = node.val.nil;
    }

    return node;
  }

  remove(node) {
    node.prev = node.next;
  }

}

class QuadListNode {
  constructor(val) {
    this.prev = this;
    this.next = this;
    this.above = null;
    this.below = null;
    this.val = val;
  }

}

class QuadList {
  constructor() {
    this.nil = new QuadListNode();
  }

  static insertAboveAfter(newNode, belowNode, leftNode) {
    newNode.next = leftNode.next;
    leftNode.next.prev = newNode;
    leftNode.next = newNode;

    if (belowNode) {
      belowNode.above = newNode;
    }

    newNode.prev = leftNode;
    newNode.below = belowNode;
  }

  static remove(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }

}
/**
 * a probabilistic data structure.
 * @category SkipList
 * @description
 * `search`, `insert`, `remove` achieve O(Logn) expected performance.
 * @example
 * ```js
 * const sl = new SkipList()
 * sl.insert(3)
 * sl.insert(1)
 * sl.insert(5)
 * sl.search(1) // => 1
 * ```
 */


class SkipList {
  constructor(fn = x => x) {
    this.dl = new DoubleLink();
    this.mapValueKey = fn;
  }

  _search(key, dlNode = this.dl.firstLevel(), qlNode = dlNode.val.nil) {
    const tail = dlNode.val.nil;
    qlNode = qlNode.next;

    while (qlNode !== tail && this.mapValueKey(qlNode.val) <= key) {
      qlNode = qlNode.next;
    }

    qlNode = qlNode.prev;

    if (!qlNode.below) {
      return {
        dlNode,
        qlNode
      };
    }

    qlNode = qlNode.below;
    return this._search(key, dlNode.next, qlNode);
  }

  search(key) {
    const {
      qlNode
    } = this._search(key);

    if (this.mapValueKey(qlNode.val) === key) {
      return qlNode.val;
    }

    return null;
  }

  insert(value) {
    let {
      qlNode,
      dlNode
    } = this._search(this.mapValueKey(value));

    const newqlNode = new QuadListNode(value);
    QuadList.insertAboveAfter(newqlNode, null, qlNode);
    let belowNode = newqlNode;

    while (Math.random() < 0.5) {
      const newqlNode = new QuadListNode(value);

      while (qlNode !== dlNode.val.nil && !qlNode.above) {
        qlNode = qlNode.prev;
      }

      if (qlNode === dlNode.val.nil && dlNode.prev === this.dl.nil) {
        dlNode = this.dl.insert();
        qlNode = dlNode.val.nil;
      } else {
        if (!qlNode.above) {
          throw new Error('qlNode above must not be null');
        }

        qlNode = qlNode.above;
        dlNode = dlNode.prev;
      }

      QuadList.insertAboveAfter(newqlNode, belowNode, qlNode);
      belowNode = newqlNode;
    }
  }

  min() {
    const tail = this.dl.nil.prev;
    return tail.val.nil.next.val;
  }

  max() {
    const tail = this.dl.nil.prev;
    return tail.val.nil.prev.val;
  }

  remove(key) {
    let {
      qlNode
    } = this._search(key);

    if (this.mapValueKey(qlNode.val) === key) {
      QuadList.remove(qlNode);

      while (qlNode.above) {
        qlNode = qlNode.above;
        QuadList.remove(qlNode);
      }
    }
  }

}

class SegmentTree {
  constructor(arr, getLeafValue, getNotLeafValue) {
    this.arr = arr;
    this.getLeafValue = getLeafValue;
    this.getNotLeafValue = getNotLeafValue;
    const n = arr.length;
    this.tree = Array(4 * n);

    this._build(0, 0, n - 1);
  }

  _build(u, l, r) {
    if (l === r) {
      this.tree[u] = {
        l,
        r,
        v: this.getLeafValue(this.arr[l])
      };
      return;
    }

    let m = Math.floor((l + r) / 2);

    this._build(2 * u + 1, l, m);

    this._build(2 * u + 2, m + 1, r);

    this.tree[u] = {
      l,
      r,
      v: this.getNotLeafValue(this.tree[2 * u + 1].v, this.tree[2 * u + 2].v)
    };
  }

  _update(u, pos, v) {
    const {
      l,
      r
    } = this.tree[u];

    if (pos < l || pos > r) {
      return;
    }

    if (l === r) {
      if (l === pos) {
        this.tree[u].v = this.getLeafValue(v);
      }

      return;
    }

    let m = Math.floor((l + r) / 2);

    if (pos > m) {
      this._update(2 * u + 2, pos, v);
    } else {
      this._update(2 * u + 1, pos, v);
    }

    this.tree[u].v = this.getNotLeafValue(this.tree[2 * u + 1].v, this.tree[2 * u + 2].v);
  }

}
/**
 * Max segment tree.
 * Query the maximum value of given range and update the value in O(Logn) time.
 *
 * @category segment tree
 * @example
 * ```js
 * const maxArr = new MaxArr([2,3,1,7,9])
 * const [l,r]=[0,2]
 * // find the maximum value from [l,r]
 * maxArr.query(l,r) //=> 3
 * maxArr.query(0,3) //=> 7
 * maxArr.update(1,9)
 * maxArr.query(0,3) //=> 9
 * ```
 * Provide the specified key
 * ```js
 * const maxArr = new MaxArr([{ name: 'li', age: 21 }, { name: 'wang', age: 24 }, { name: 'xx', age: 23 }],node=>node.age)
 * maxArr.query(0,2) //=> { name: 'wang', age: 24 }
 * maxArr.update(0, { name: 'xiao', age: 25 })
 * maxArr.query(0,2) //=> { name: 'xiao', age: 25 }
 * ```
 */


class MaxArr extends SegmentTree {
  constructor(arr, mapValueKey = x => x) {
    super(arr, x => x, (x, y) => {
      return mapValueKey(x) - mapValueKey(y) >= 0 ? x : y;
    });
    this.mapValueKey = mapValueKey;
  }

  _query(u, l, r) {
    const {
      l: _l,
      r: _r,
      v
    } = this.tree[u];

    if (l <= _l && r >= _r) {
      return v;
    }

    if (r < _l || l > _r) {
      return;
    }

    let v1 = this._query(2 * u + 1, l, r);

    let v2 = this._query(2 * u + 2, l, r);

    if (v1 === undefined) {
      return v2;
    } else if (v2 === undefined) {
      return v1;
    }

    return this.getNotLeafValue(v1, v2);
  }

  query(start = 0, end = this.arr.length - 1) {
    return this._query(0, start, end);
  }

  update(pos, value) {
    this.arr[pos] = value;

    this._update(0, pos, value);
  }

}
/**
 * Sum segment tree.
 * Query the sum of given range and update the value in O(Logn) time.
 * @category segment tree
 * @example
 * ```js
 * const sumArr = new SumArr([2,3,1,7,9])
 * sumArr.query(0,2)
 * ```
 */

class SumArr extends SegmentTree {
  constructor(arr) {
    super(arr, x => x, (x, y) => x + y);
  }

  _query(u, l, r) {
    const {
      l: _l,
      r: _r,
      v
    } = this.tree[u];

    if (l <= _l && r >= _r) {
      return v;
    }

    if (r < _l || l > _r) {
      return 0;
    }

    let v1 = this._query(2 * u + 1, l, r);

    let v2 = this._query(2 * u + 2, l, r);

    return this.getNotLeafValue(v1, v2);
  }

  query(start = 0, end = this.arr.length - 1) {
    return this._query(0, start, end);
  }

  update(pos, value) {
    this.arr[pos] = value;

    this._update(0, pos, value);
  }

}
/**
 * Given an array contains all the values,
 * insert the value one by one,and
 *  query the number of value in [lower,upper].
 * @category segment tree
 * @example
 * ```js
 * const arr = [1, 2, 3, 5, 7]
 * const vArr = new ValueArr(arr)
 * vArr.insert(1)
 * vArr.insert(3)
 * vArr.insert(5)
 * assert.strictEqual(vArr.query(1, 3), 2)
 * assert.strictEqual(vArr.query(1, 5), 3)
 * vArr.insert(1)
 * assert.strictEqual(vArr.query(1, 5), 4)
 * ```
 */

class ValueArr extends SegmentTree {
  constructor(arr) {
    super(sortA(unique(arr)), () => 0, (x, y) => x + y);
  }

  _query(u, low, upper) {
    const {
      l,
      r,
      v
    } = this.tree[u];
    const lv = this.arr[l];
    const rv = this.arr[r];

    if (low <= lv && upper >= rv) {
      return v;
    } else if (low > rv || upper < lv) {
      return 0;
    }

    return this._query(2 * u + 1, low, upper) + this._query(2 * u + 2, low, upper);
  }

  query(low, upper) {
    return this._query(0, low, upper);
  }

  _insert(u, v) {
    const node = this.tree[u];
    const {
      l,
      r
    } = node;
    const lv = this.arr[l];
    const rv = this.arr[r];

    if (lv <= v && rv >= v) {
      node.v++;

      if (l < r) {
        this._insert(2 * u + 1, v);

        this._insert(2 * u + 2, v);
      }
    }
  }

  insert(v) {
    this._insert(0, v);
  }

}

/**
 * @category Union-find data structure
 * @example
 * ```js
 * const uf=new UnionFind(4);
 * uf.union(0, 1);
 * uf.union(1, 2);
 * uf.isSameSet(0, 2); //=> true
 * ```
 */
class UnionFind {
  /**
   * @param n the  number of node
   */
  constructor(n) {
    this.fatherMap = Array(n).fill(-1);
    this.sizeMap = Array(n).fill(1);
    this.size = n;
  }
  /**
   * find set representatives use `path compression`
   * @param node
   */


  find(node) {
    if (this.fatherMap[node] === -1) {
      return node;
    }

    this.fatherMap[node] = this.find(this.fatherMap[node]);
    return this.fatherMap[node];
  }

  isSameSet(node1, node2) {
    const root1 = this.find(node1);
    const root2 = this.find(node2);
    return root1 === root2;
  }
  /**
   * merge two sets
   * @param node1
   * @param node2
   */


  union(node1, node2) {
    const root1 = this.find(node1);
    const root2 = this.find(node2);

    if (root1 === root2) {
      return;
    }

    if (this.sizeMap[root1] > this.sizeMap[root2]) {
      this.fatherMap[root2] = root1;
      this.sizeMap[root2] = this.sizeMap[root2] + this.sizeMap[root1];
    } else {
      this.fatherMap[root1] = root2;
      this.sizeMap[root1] = this.sizeMap[root2] + this.sizeMap[root1];
    }
  }

}

// the typescript implementation of Manacher's linear-time algorithm.
// https://en.wikipedia.org/wiki/Longest_palindromic_substring
// returns an array representing the longest palindrome substring centered around each location
function getPalindromeArr(str) {
  let len = str.length * 2 + 1;
  let s = Array(len).fill('|');

  for (let i = 0; i < str.length; i++) {
    s[2 * i + 1] = str[i];
  }

  let palindromeRadiusArr = Array(len).fill(0);
  let center = 0;
  let radius = 0;

  while (center < len) {
    while (center - (radius + 1) >= 0 && center + (radius + 1) < len && s[center - radius - 1] === s[center + radius + 1]) {
      radius++;
    }

    palindromeRadiusArr[center] = radius;
    let oldCenter = center;
    let oldRadius = radius;
    center++;

    while (center <= oldCenter + oldRadius) {
      let diff = oldCenter + oldRadius - center;

      if (palindromeRadiusArr[oldCenter * 2 - center] === diff) {
        radius = diff;
        break;
      } else if (palindromeRadiusArr[oldCenter * 2 - center] > diff) {
        palindromeRadiusArr[center] = oldCenter + oldRadius - center;
        center++;
      } else {
        palindromeRadiusArr[center] = palindromeRadiusArr[oldCenter * 2 - center];
        center++;
      }
    }
  }

  let originPalindromeRadiusArr = Array(str.length).fill(0);

  for (let i = 0; i < originPalindromeRadiusArr.length; i++) {
    originPalindromeRadiusArr[i] = palindromeRadiusArr[2 * i + 1];
  }

  return originPalindromeRadiusArr;
}

exports.ListNode = ListNode;
exports.MaxArr = MaxArr;
exports.MaxPQ = MaxPQ;
exports.MinPQ = MinPQ;
exports.RBST = RBST;
exports.SkipList = SkipList;
exports.SumArr = SumArr;
exports.TreeNode = TreeNode;
exports.UnionFind = UnionFind;
exports.ValueArr = ValueArr;
exports.bit = bit;
exports.bitCount = bitCount;
exports.c = c;
exports.cm = cm;
exports.countOfUniqueA = countOfUniqueA;
exports.countOfUniqueD = countOfUniqueD;
exports.gcd = gcd;
exports.getConnectedNumByAdjArr = getConnectedNumByAdjArr;
exports.getConnectedNumByAdjMatrix = getConnectedNumByAdjMatrix;
exports.getPalindromeArr = getPalindromeArr;
exports.hopcroftKarp = hopcroftKarp;
exports.init2Array = init2Array;
exports.initArray = initArray;
exports.inorder = inorder;
exports.intersect = intersect;
exports.listNode = listNode;
exports.max = max;
exports.maxIntervalDisjoint = maxIntervalDisjoint;
exports.medium = medium;
exports.mergeArray = mergeArray;
exports.min = min;
exports.minCoverVertices = minCoverVertices;
exports.minIntervalCover = minIntervalCover;
exports.mod = mod;
exports.nextPermutation = nextPermutation;
exports.postorder = postorder;
exports.prevorder = prevorder;
exports.random = random;
exports.reverse = reverse;
exports.rotate90 = rotate90;
exports.rotateCw90 = rotateCw90;
exports.sortA = sortA;
exports.sortD = sortD;
exports.sum = sum;
exports.toIndexArr = toIndexArr;
exports.treeNode = treeNode;
exports.unique = unique;
//# sourceMappingURL=algm.cjs.development.js.map
